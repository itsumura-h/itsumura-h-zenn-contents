---
title: "Rustã‚’Nimã‹ã‚‰å‘¼ã³å‡ºã™"
emoji: "ğŸ‘‘"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [
  "nim", "rust"
]
published: true
---

## ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³
Nimã¯Pythonã®ã‚ˆã†ãªç°¡å˜ãªæ–‡æ³•ã§ã€Cè¨€èªã«ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«ã—ãƒã‚¤ãƒŠãƒªã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ã§ã€å­¦ç¿’ã‚³ã‚¹ãƒˆã®ä½ã•ã€é–‹ç™ºã®ç”Ÿç”£æ€§ã®é«˜ã•ã€å®Ÿè¡Œé€Ÿåº¦ã®é€Ÿã•ã‚’å…¼ã­æƒãˆãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã™ã€‚
æ‰€æœ‰æ¨©ãƒ»å€Ÿç”¨ã«åŸºã¥ãã‚¹ã‚³ãƒ¼ãƒ—ãƒ™ãƒ¼ã‚¹ã§ã®å®‰å…¨ãªãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒè‡ªå‹•ã§è¡Œã„ã€å‚ç…§ã‚„ãƒã‚¤ãƒ³ã‚¿ã«ã¤ã„ã¦è€ƒãˆã‚‹å¿…è¦ã‚‚ãªã„ãŸã‚ã€ç‰¹ã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã«ãŠã„ã¦ã€Œã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãŸã‚ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚’æ¸›ã‚‰ã›ã¦ãã®è¨˜è¿°ã‚’ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã ã‘ã«é›†ä¸­ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã—ã‹ã—ã¾ã æ™®åŠã—ã¦ã„ã‚‹ã¨ã¯è¨€ã„é›£ãã€ä½¿ã‚ãªã„äººã®æ„è¦‹ã‚’èãã¨ã€Œãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå°‘ãªã„ã€ã¨ã„ã†ç†ç”±ã‚’å¤šãèãã¾ã™ã€‚
Nimã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ä¸€æ—¦Cè¨€èªã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ã€æ—¢ã«Cè¨€èªã§å­˜åœ¨ã—ã¦ã„ã‚‹è³‡ç”£ã‚’ç°¡å˜ã«å–ã‚Šè¾¼ã‚€ã“ã¨ãŒã§ãã€å‹•çš„ãƒªãƒ³ã‚¯ãƒ»é™çš„ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ä¸¡æ–¹ã¨éå¸¸ã«ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã«é€£æºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä¸€æ–¹ã§Rustã¯ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãŠã‘ã‚‹ãƒ¡ãƒ¢ãƒªå®‰å…¨ã‚’å¾¹åº•ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã€ã‚»ã‚°ãƒ•ã‚©ã‚„ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’é˜²ãéå¸¸ã«é«˜é€Ÿã«å‹•ä½œã—ã¾ã™ã€‚
ã—ã‹ã—å¤‰æ•°ã®æ‰€æœ‰æ¨©ã‚„å€Ÿç”¨ã‚’é–‹ç™ºæ™‚ã«è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ã¨ã¦ã‚‚å­¦ç¿’ã‚³ã‚¹ãƒˆãŒé«˜ã„ã§ã™ã€‚å°‘ãªãã¨ã‚‚æ–‡ç³»å‡ºèº«2å¹´ç›®PHPerãŒç°¡å˜ã«æ‰±ãˆã‚‹ã‚ˆã†ãªè¨€èªã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ã“ã®2ã¤ã®è¨€èªã®ç‰¹å¾´ã‚’è€ƒãˆãŸæ™‚ã«ã€æ•°å­¦ã«åŸºã¥ãã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…ãªã©ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯Rustã§ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯Nimã§ä½œã‚‹ã¨ä¸¡è€…ã®ã„ã„ã¨ã“å–ã‚ŠãŒã§ãã‚‹ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ã€‚

Nimã€Rustä¸¡æ–¹å…±ã«Cè¨€èªã‚’ä»‹ã—ãŸFFIã®æ©Ÿæ§‹ãŒå‚™ã‚ã£ã¦ã„ã‚‹ãŸã‚ã€ä»Šå›ã¯ãã‚Œã‚’ä½¿ã£ã¦Rustã§ä½œã£ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’Nimã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰å‘¼ã¶å®Ÿé¨“ã‚’ã—ã¾ã™ã€‚

:::message alert
ç­†è€…ã¯Rust1é€±é–“ã®åˆå¿ƒè€…ã§ã™ã€‚Nimã¯é•·ãè§¦ã£ã¦ã„ã¾ã™ãŒã€Cè¨€èªã®çµŒé¨“ã‚‚ãªã„PHPerå‡ºèº«ã§LLè¨€èªã°ã‹ã‚Šã‚„ã£ã¦ãã¾ã—ãŸã€‚
Rustã®ä½¿ã„æ–¹ã‚„ãƒ¡ãƒ¢ãƒªç®¡ç†ã«ã¤ã„ã¦é–“é•ã£ãŸè¨˜è¿°ã‚’ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ã‚‚ã—ç™ºè¦‹ã—ãŸå ´åˆã¯ãŠæ°—è»½ã«ã‚³ãƒ¡ãƒ³ãƒˆãã ã•ã„ã€‚
:::

## ç’°å¢ƒæ§‹ç¯‰
Nimã¨Rustä¸¡æ–¹ã®ç’°å¢ƒãŒå…¥ã£ãŸDockerã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œã‚Šã¾ã™ã€‚

```dockerfile
FROM ubuntu:22.04

# prevent timezone dialogue
ENV DEBIAN_FRONTEND=noninteractive

RUN apt update --fix-missing && \
    apt upgrade -y
RUN apt install -y --fix-missing \
        gcc \
        xz-utils \
        ca-certificates \
        curl \
        pkg-config

WORKDIR /root
# ==================== Nim ====================
RUN curl https://nim-lang.org/choosenim/init.sh -sSf | sh -s -- -y
ENV PATH $PATH:/root/.nimble/bin

# ==================== Rust ====================
RUN curl https://sh.rustup.rs -sSf | sh -s -- -y

WORKDIR /application
```

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
`/application`é…ä¸‹ã«`src`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œã‚Šãã“ã§ä½œæ¥­ã—ã¾ã™ã€‚


Nimã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹
```sh
cd /application/src
nimble init nimapp
```
å¯¾è©±å‹ã§èã‹ã‚Œã‚‹ã®ã§ã€é¸æŠè‚¢ã‚’Tabã§ã‚µã‚¤ã‚¯ãƒ«ã—ã¦Enterã§é¸ã³ã¾ã™ã€‚
`Package type?`ã§ã¯`Binary`ã‚’é¸ã³ã¾ã™ã€‚

```sh
  Info: Package initialisation requires info which could not be inferred.
    ... Default values are shown in square brackets, press
    ... enter to use them.
  Using "nimapp" for new package name
Prompt: Your name? [Anonymous]

Answer:       Using "src" for new package source directory
Prompt: Package type?
    ... Library - provides functionality for other packages.
    ... Binary  - produces an executable for the end-user.
    ... Hybrid  - combination of library and binary
    ... For more information see https://goo.gl/cm2RX5
  Select Cycle with 'Tab', 'Enter' when done
Answer: binary
Prompt: Initial version of package? [0.1.0]

Answer:     Prompt: Package description? [A new awesome nimble package]

Answer:     Prompt: Package License?
    ... This should ideally be a valid SPDX identifier. See https://spdx.org/licenses/.
  Select Cycle with 'Tab', 'Enter' when done
Answer: MIT
Prompt: Lowest supported Nim version? [1.6.10]

Answer:    Success: Package nimapp created successfully
```


Rustã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹
```sh
cd /application/src
cargo new rustlib --lib
```

ã“ã†ã„ã†ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã«ãªã‚Šã¾ã™

```
/application
`-- src
    |-- nimapp
    |   |-- nimapp.nimble
    |   |-- src
    |   |   `-- nimapp.nim
    |   `-- tests
    |       |-- config.nims
    |       `-- test1.nim
    `-- rustlib
        |-- Cargo.toml
        `-- src
            `-- lib.rs
```


## é–¢æ•°ã‚’å‘¼ã¶
ã¾ãšã¯ç°¡å˜ãªã€intã‚’è¶³ã—ç®—ã™ã‚‹addé–¢æ•°ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### Rustå´

```rust:lib.rs
#[no_mangle]
pub extern "C" fn add(a: i64, b: i64) -> i64 {
    return a + b;
}
```

```
#[no_mangle]
```
ã“ã‚Œã‚’é–¢æ•°ã«å¯¾ã—ã¦ä»˜ã‘ã‚‹ã“ã¨ã§ã€C/Nimã‹ã‚‰ã€Rustã§å®šç¾©ã—ãŸé€šã‚Šã®`add`ã®é–¢æ•°åã§å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```rs
pub extern "C"
```
é–¢æ•°ã«å¯¾ã—ã¦ã“ã‚Œã‚’ä»˜ã‘ã‚‹ã“ã¨ã§ã€C/Nimã‹ã‚‰å‘¼ã³å‡ºã›ã‚‹é–¢æ•°ã«ãªã‚Šã¾ã™ã€‚

https://tomoyuki-nakabayashi.github.io/book/interoperability/rust-with-c.html#c-api%E3%81%AE%E4%BD%9C%E6%88%90


ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å‡ºåŠ›ã™ã‚‹æ™‚ã«ã¯ã€`crate-type`ã‚’è¨­å®šã—ã¾ã™ã€‚
å‹•çš„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ™‚ã«ã¯`cdylib`ã‚’ã€é™çš„ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ™‚ã«ã¯`staticlib`ã«ã—ã¾ã™ã€‚

```toml:Cargo.toml
[package]
name = "rustlib"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name         = "rustlib"
crate-type   = ["cdylib"]
# crate-type   = ["staticlib"]
```

https://qiita.com/etoilevi/items/4bd4c5b726e41f5a6689


ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚
```sh
cd /application/src/rustlib
cargo build --release
```
`/application/src/rustlib/target/release/librustlib.so`ã«Shard Objectãƒ•ã‚¡ã‚¤ãƒ«ãŒå‡ºåŠ›ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã‚’Nimã‹ã‚‰å‘¼ã³å‡ºã—ã¦ä½¿ã„ã¾ã™ã€‚

### Nimå´
`/application/src/nimapp/src/rustlib.nim`ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚Šã€Shard Objectã«ã‚ã‚‹é–¢æ•°ã‚’Nimã‹ã‚‰å‘¼ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ã‚°ãƒ«ãƒ¼é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚

```nim:rustlib.nim
const libpath = "/application/src/rustlib/target/release/librustlib.so"

proc add*(a, b:int64):int64 {.dynlib:libpath, importc: "add".}
```

é™çš„ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚’å‘¼ã³å‡ºã™æ™‚ã«ã¯ã“ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚
```nim:rustlib.nim
const libpath = "/application/src/rustlib/target/release/librustlib.a"

{.passL:libpath.}
proc add*(a, b:int64):int64 {.cdecl, importc: "add".}
```


ã‚ã¨ã¯`nimapp.nim`ã‹ã‚‰ã“ã®`add`é–¢æ•°ã‚’å‘¼ã³å‡ºã›ã°ã„ã„ã ã‘ã§ã™ã€‚
```nim:nimapp.nim
import std/unittest
import ./rustlib

suite "test":
  test "add":
    echo add(1, 2)
    check add(1, 2) == 3
```

å®Ÿè¡Œã—ã¾ã—ã‚‡ã†ã€‚
```sh
cd /application/src/nimapp
nim c -r -f --mm:orc src/nimapp
```
```sh:output
[Suite] test
3
  [OK] add
```

å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

## å‹•çš„é…åˆ—ã‚’æ‰±ã†
Rustã®Vectorã‚’Nimã§æ‰±ã†ã«ã¯ã©ã†ã™ã‚Œã°ã„ã„ã§ã—ã‚‡ã†ã‹ã€‚
ã“ã“ã§ã¯ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’è¿”ã™é–¢æ•°ã‚’ä½¿ã£ã¦èª¬æ˜ã—ã¾ã™ã€‚

### Rustå´
ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¿”ã™é–¢æ•°ã€ãã‚Œã‚’å†…éƒ¨ã§å‘¼ã‚“ã§ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’è¿”ã™é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚

```rust:lib.rs
fn fib(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 2) + fib(n - 1),
    }
}

#[no_mangle]
pub extern "C" fn fib_array(n: u64) -> *mut Vec<u64> {
    let mut vector = Vec::with_capacity(n.try_into().unwrap());
    for i in 0..n {
        vector.push(fib(i));
    }
    Box::into_raw(Box::new(vector))
}

#[no_mangle]
pub extern "C" fn get_fib_len(v: &mut Vec<u64>) -> usize {
    v.len()
}

#[no_mangle]
pub extern "C" fn get_fib_item(v: &mut Vec<u64>, offset: usize) -> u64 {
    v[offset]
}
```

fib_arrayã®è¿”ã‚Šå€¤ã®å‹ã¯`*mut Vec<u64>`ã«ã—ã€é–¢æ•°ã®æœ€å¾Œã§`Box::into_raw(Box::new(vector))`ã‚’å‘¼ã‚“ã§ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ã«ã—ã¦è¿”ã—ã¾ã™ã€‚
æ›´ã«Vectorã‹ã‚‰é•·ã•ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆä½ç½®ã®å€¤ã‚’è¿”ã™é–¢æ•°ã‚‚å®Ÿè£…ã—ã¾ã™ã€‚

### Nimå´

```nim:rustlib.nim
type FibPtr = ptr object

proc fibArrayLib(n:uint64):FibPtr {.dynlib:libpath, importc: "fib_array".}
proc len(self:FibPtr):int {.dynlib:libpath, importc: "get_fib_len".}
proc `[]`(self:FibPtr, offset:int):int {.dynlib:libpath, importc: "get_fib_item".}
proc fibArray*(n:int):seq[int] =
  let v = fibArrayLib(n.uint64)
  defer: v.dealloc()
  var s = newSeq[int](n)
  for i in 0..<v.len:
    s[i] = v[i]
  return s
```

Rustã®`get_fib_len`ã®è¿”ã‚Šå€¤ã¯ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ãªã®ã§ã€ãã‚Œã‚’ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ãŸã‚ã®ç‹¬è‡ªã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’`FibPtr`ã¨ã—ã¦å®šç¾©ã—ã¾ã™ã€‚
Nimã®é–¢æ•°ã¯å…¨ã¦é™çš„ãªå‹ãƒã‚§ãƒƒã‚¯ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦å‹•ãã®ã§ã€ã“ã“ã§å®šç¾©ã—ãŸé–¢æ•°ã¯å…¨ã¦`FibPtr`ã®å‹ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã®ã¿å‹•ãã¾ã™ã€‚
`fibArray`é–¢æ•°ã®ä¸­ã§Rustå´ã§å®šç¾©ã—ãŸé–¢æ•°ãŸã¡ã‚’å‘¼ã³ã€ç”Ÿãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰Vectorã®é•·ã•ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆä½ç½®ã®å€¤ã‚’å–å¾—ã—ã€Nimã®å‹•çš„é…åˆ—ã§ã‚ã‚‹Seq(Sequence)ã«è©°ã‚æ›¿ãˆã¦è¿”ã—ã¦ã„ã¾ã™ã€‚
Nimã§ã¯ç”Ÿãƒã‚¤ãƒ³ã‚¿ã¯Nimã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã®ç®¡è½„å¤–ã«ãªã‚Šã¾ã™ã€‚ãƒã‚¤ãƒ³ã‚¿ã®ãƒ¡ãƒ¢ãƒªã‚’é–‹æ”¾ã™ã‚‹`dealloc`é–¢æ•°ãŒç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€`defer`ã‚’ä½¿ã£ã¦ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã¨ãƒ¡ãƒ¢ãƒªãŒé–‹æ”¾ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ã“ã®`defer`ã¯Goè¨€èªã¨åŒã˜ã§ã™ã€‚

ã§ã¯`nimapp`ã®ä¸­ã§å‘¼ã³å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "test":
  test "add":
    echo add(1, 2)
    check add(1, 2) == 3

  test "fib array":
    let res = fibArray(10)
    echo res
    check res == @[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

```sh
cd /application/src/nimapp
nim c -r -f --mm:orc src/nimapp
```
```sh:output
[Suite] test
3
  [OK] add
@[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
  [OK] fib array
```

å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã—ãŸã€‚


:::message
## å‡¦ç†ã‚’ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ç§»å‹•ã•ã›ã‚‹
ã“ã“ã¾ã§addé–¢æ•°ã¨ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’å‡ºåŠ›ã™ã‚‹é–¢æ•°ã‚’`lib.rs`ã«æ›¸ã„ã¦ãã¾ã—ãŸãŒã€ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ç§»ã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ãã®æ–¹ãŒã‚³ãƒ¼ãƒ‰ã®è¦‹é€šã—ãŒã‚ˆããªã‚‹ã®ã§ã€ç§»ã—ã¾ã—ã‚‡ã†ã€‚

Rustã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’ã“ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚

```
.
|-- Cargo.lock
|-- Cargo.toml
`-- src
    |-- lib.rs
    `-- submods
        `-- fib.rs
```

fib.rsã«å‡¦ç†ã‚’ç§»å‹•ã•ã›ã¾ã™ã€‚
```rust:submods/fib.rs
fn fib(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 2) + fib(n - 1),
    }
}

#[no_mangle]
pub extern "C" fn fib_array(n: u64) -> *mut Vec<u64> {
    let mut vector = Vec::with_capacity(n.try_into().unwrap());
    for i in 0..n {
        vector.push(fib(i));
    }
    Box::into_raw(Box::new(vector))
}

#[no_mangle]
pub extern "C" fn get_vector_len(v: &Vec<u64>) -> usize {
    v.len()
}

#[no_mangle]
pub extern "C" fn get_vector_item(v: &Vec<u64>, offset: usize) -> u64 {
    v[offset]
}
```

lib.rsã¯ã“ã®ã‚ˆã†ã«ã—ã¾ã™
```rust:lib.rs
mod submods {
    pub mod fib;
}

#[no_mangle]
pub extern "C" fn add(a: i64, b: i64) -> i64 {
    return a + b;
}
```
:::

## ã‚«ã‚¹ã‚¿ãƒ å‹ï¼ˆç‹¬è‡ªå‹ã€æ§‹é€ ä½“ï¼‰ã‚’æ‰±ã†
Rustã®ä¸­ã§å®šç¾©ã—ãŸæ§‹é€ ä½“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’Nimã‹ã‚‰æ‰±ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

### Rustå´
`submods/person.rs`ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚Šã¾ã™ã€‚
æ•°å€¤ã¨æ–‡å­—åˆ—ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤`Person`å‹ã¨ã€ãã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ã‚²ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¾ã™ã€‚
FFIã«å‡ºåŠ›ã™ã‚‹é–¢æ•°åã¯ãªã‚‹ã¹ãè¢«ã‚‰ãªã„ã‚ˆã†ãªå‘½åã«ã—ãŸæ–¹ãŒã„ã„ã§ã—ã‚‡ã†ã€‚ãã®ãŸã‚ãŸã idã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰åã‚‚`id`ã§ã¯ãªã`get_person_id`ã¨ã—ã¦ã„ã¾ã™ã€‚

```diff rust:lib.rs
  mod submods {
      pub mod fib;
+     pub mod c_ffi;
+     pub mod person;
  }

+ use crate::submods::c_ffi;

  #[no_mangle]
  pub extern "C" fn add(a: i64, b: i64) -> i64 {
      return a + b;
  }
```

```rust:submods/person.rs
use std::ffi::c_char;
use crate::c_ffi;


pub struct Person {
    id: i64,
    name: String,
}

impl Person {
    pub fn new(id: i64, name: String) -> Box<Person> {
        let person = Box::new(Person { id, name });
        person
    }

    pub fn id(&self) -> i64 {
        self.id
    }

    pub fn name(&self) -> String {
        self.name.to_string()
    }
}

// ==================== FFI ====================
#[no_mangle]
pub extern "C" fn new_person(id: i64, _name: *const c_char) -> *mut Person {
    let name = c_ffi::cstirng_to_string(_name);
    let person = Person::new(id, name);
    Box::into_raw(person)
}

#[no_mangle]
pub extern "C" fn get_person_id(person: &Person) -> i64 {
    person.id()
}

#[no_mangle]
pub extern "C" fn get_person_name(person: &Person) -> *mut c_char {
    c_ffi::string_to_cstring(person.name())
}

// ==================== test ====================
#[cfg(test)]
mod person_tests {
    use super::*;

    #[test]
    fn person_test() {
        let person = Person::new(1, "John".to_string());
        assert_eq!(person.id(), 1);
        assert_eq!(person.name(), "John");
    }
}
```

`new_person`é–¢æ•°ã®å¼•æ•°nameã®å‹ã¯`*const c_char`ã«ãªã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯Cè¨€èªã®æ–‡å­—åˆ—ã‚’Rustã§æ‰±ã†ãŸã‚ã®å‹ã§ã™ã€‚
åå¯¾ã«Rustâ†’Cè¨€èªã¸æ–‡å­—åˆ—ã‚’è¿”ã™ã«ã¯`*mut c_char`ã«ã—ã¾ã™ã€‚

`new_person`é–¢æ•°ã®è¿”ã‚Šå€¤ã®å‹ã¯`*mut Person`ã§ã™ã€‚ã“ã‚Œã¯å…ˆã»ã©ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã¨åŒã˜ãã€ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ã«ãªã£ã¦ã„ã¾ã™ã€‚

Nimã®æ–‡å­—åˆ—ã‚‚Rustã®æ–‡å­—åˆ—ã‚‚ãã‚Œãã‚Œã®è¨€èªã®å®Ÿè¡Œç’°å¢ƒã®ä¸­ã§ã¿å‹•ä½œã™ã‚‹ç‹¬è‡ªã®å‹ã§ã™ã€‚
ãã®ãŸã‚Cè¨€èªã‚’ä»‹ã—ã¦Nimã‹ã‚‰Rustã¸æ–‡å­—åˆ—ã‚„ã‚Šã¨ã‚Šã™ã‚‹ãŸã‚ã«ã¯ã€ç›¸äº’ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã“ã§ã¯ã¾ãšRustå´ã«Cè¨€èªã®æ–‡å­—åˆ—ã‚’ç›¸äº’å¤‰æ›ã™ã‚‹é–¢æ•°ã‚’ä½œã‚Šã¾ã—ãŸã€‚

```rust:submods/c_ffi.rs
use std::ffi::c_char;
use std::ffi::CStr;
use std::ffi::CString;

pub fn cstirng_to_string(_arg: *const c_char) -> String {
    let arg = unsafe {
        assert!(!_arg.is_null());
        let c_str = CStr::from_ptr(_arg);
        let str_slice = c_str.to_str().unwrap();
        drop(c_str);
        str_slice.to_owned()
    };
    arg
}

pub fn string_to_cstring(_arg: String) -> *mut c_char {
    CString::new(_arg).unwrap().into_raw()
}
```

`person.rs`ã§ã¯ã“ã‚Œã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚

### Nimå´

```nim:rustlib.nim
type
  PersonObj {.pure, final.} = object
    id:int
    name:cstring

  PersonPtr = ptr PersonObj

  Person* = ref object
    rawPtr: PersonPtr


proc newPerson(id:int, name:cstring):PersonPtr {.dynlib:libpath, importc:"new_person".}
proc new*(_:type Person, id:int, name:string):Person = Person(rawPtr:newPerson(id, name.cstring))

proc getPersonId(self:PersonPtr):int64 {.dynlib:libpath, importc:"get_person_id".}
proc id*(self:Person):int = self.rawPtr.getPersonId().int

proc getPersonName(self:PersonPtr):cstring {.dynlib:libpath, importc:"get_person_name".}
proc name*(self:Person):string = $self.rawPtr.getPersonName()
```

Rustã®æ§‹é€ ä½“å®šç¾©ã¨åŒã˜æ§‹é€ ä½“ã‚’Nimã®objectã§å®šç¾©ã—ã¾ã™ã€‚

å®Ÿéš›ã«Rustã®é–¢æ•°ã¨ã‚„ã‚Šã¨ã‚Šã™ã‚‹ã®ã¯ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ãªã®ã§ã€ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ãŸã‚ã®ãƒã‚¤ãƒ³ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ`PersonPtr`ã‚’å®šç¾©ã—ã¾ã™ã€‚
ãƒã‚¤ãƒ³ã‚¿ã¯Nimã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã®ç®¡è½„å¤–ã«ãªã‚Šã¾ã™ãŒã€ãƒã‚¤ãƒ³ã‚¿ã®å‹ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«æŒã¤`ref`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è‡ªå‹•ã§ãƒ¡ãƒ¢ãƒªç®¡ç†ã•ã‚Œã‚‹ã®ã§ã€`Person* = ref object`ã‚’å®šç¾©ã—Nimã‹ã‚‰ã¯ã“ã¡ã‚‰ã‚’æ‰±ã†ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Š`dealloc`ä½¿ã£ã¦æ˜ç¤ºçš„ã«ãƒ¡ãƒ¢ãƒªè§£æ”¾ã‚’ã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚

`newPerson`ã®å¼•æ•°nameã®å‹ã¯`cstring`ã§ã™ã€‚ã“ã‚ŒãŒNimã®ä¸­ã§ã®Cè¨€èªã®æ–‡å­—åˆ—ã«ç›¸å½“ã—ã€`"æ–‡å­—åˆ—".cstring`ã¨ã™ã‚Œã°å‹å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

`name`é–¢æ•°ã®ä¸­ã§ã¯`getPersonName`ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ãŒã€`getPersonName`ã®è¿”ã‚Šå€¤ã®å‹ã¯`cstring`ãªã®ã§ã€`$`ã‚’ä»˜ã‘ã¦`string`ã«å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚`$`ã¯Nimã®ä¸–ç•Œã§ã¯ã‚ã‚‰ã‚†ã‚‹å‹ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ãƒã‚¸ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ï¼ˆå®Ÿéš›ã«ã¯å…¨ã¦ã®å‹ã«`$`ã¨ã„ã†åŒåã®é–¢æ•°åã§æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ï¼‰

```nim
proc new*(_:type Person, id:int, name:string):Person = Person(rawPtr:newPerson(id, name.cstring))
proc id*(self:Person):int = self.rawPtr.getPersonId().int
proc name*(self:Person):string = $self.rawPtr.getPersonName()
```
ã“ã®3ã¤ã®é–¢æ•°ã¯Nimã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰å‘¼ã³å‡ºã•ã‚ŒRustã®é–¢æ•°ã¨ãƒãƒƒãƒ”ãƒ³ã‚°ã—ãŸ`newPerson`ãªã©ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™å‡¦ç†ã¨å‹å¤‰æ›ã‚’è¡Œã†ã‚°ãƒ«ãƒ¼ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚

ã§ã¯å‘¼ã³å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "object":
  test "person":
    let person = Person.new(1, "John")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 1
      person.name() == "John"
```
```sh:output
[Suite] object
Person(rawPtr: PersonPtr(id: 1, name: "John"))
1
John
  [OK] person
```
`PersonPtr`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®å€¤ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚‚ã€é–¢æ•°å‘¼ã³ã ã—ã‚‚ä¸Šæ‰‹ãè¡Œã£ã¦ã„ã¾ã™ã€‚

## ã‚»ãƒƒã‚¿ãƒ¼ã‚’æŒã¤ç‹¬è‡ªå‹ã‚’æ‰±ã†
ã“ã‚Œã¾ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã¨ã‚²ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã—ã‹æ‰±ã£ã¦ã„ã¾ã›ã‚“ãŒã€ã‚»ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚‚ä¸Šæ‰‹ãã„ãã§ã—ã‚‡ã†ã‹
ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ãŒã§ãã‚‹`UpdatablePerson`å‹ã‚’ä½¿ã£ã¦èª¬æ˜ã—ã¾ã™ã€‚

### Rustå´
```diff rust:lib.rs
  mod submods {
      pub mod fib;
      pub mod c_ffi;
      pub mod person;
+     pub mod updatable_person;
  }

  use crate::submods::c_ffi;

  #[no_mangle]
  pub extern "C" fn add(a: i64, b: i64) -> i64 {
      return a + b;
  }
```

```rust:submods/update_person.rs
use std::ffi::c_char;
use crate::submods::c_ffi;

pub struct UpdatablePerson {
    id: i64,
    name: String,
}

impl UpdatablePerson {
    pub fn new(id: i64, name: String) -> Box<UpdatablePerson> {
        let person = Box::new(UpdatablePerson { id, name });
        person
    }

    pub fn id(&self) -> i64 {
        self.id
    }

    pub fn set_id(&mut self, id: i64) {
        self.id = id
    }

    pub fn name(&self) -> String {
        self.name.to_string()
    }

    pub fn set_name(&mut self, name: String) {
        self.name = name
    }
}


#[no_mangle]
pub extern "C" fn new_updatable_person(id: i64, _name: *const c_char) -> *mut UpdatablePerson {
    let name = c_ffi::cstirng_to_string(_name);
    let person = UpdatablePerson::new(id, name);
    Box::into_raw(person)
}

#[no_mangle]
pub extern "C" fn get_updatable_person_id(person: &UpdatablePerson) -> i64 {
    person.id()
}

#[no_mangle]
pub extern "C" fn set_updatable_person_id(person: &mut UpdatablePerson, id: i64) {
    person.set_id(id)
}

#[no_mangle]
pub extern "C" fn get_updatable_person_name(person: &UpdatablePerson) -> *mut c_char {
    c_ffi::string_to_cstring(person.name())
}

#[no_mangle]
pub extern "C" fn set_updatable_person_name(person: &mut UpdatablePerson, _name: *const c_char) {
    let name = c_ffi::cstirng_to_string(_name);
    person.set_name(name)
}


#[cfg(test)]
mod updatable_person_test {
    use super::*;

    #[test]
    fn test1() {
        let mut person = UpdatablePerson::new(1, "John".to_string());
        assert_eq!(person.id(), 1);
        assert_eq!(person.name(), "John");
        person.set_id(2);
        person.set_name("Paul".to_string());
        assert_eq!(person.id(), 2);
        assert_eq!(person.name(), "Paul");
    }
}
```

### Nimå´
```nim:rustlib.nim
type
  UpdatablePersonObj {.pure, final.} = object
    id:int
    name:cstring

  UpdatablePersonPtr = ptr UpdatablePersonObj

  UpdatablePerson* = ref object
    rawPtr: UpdatablePersonPtr


proc newUpdatablePerson(id:int, name:cstring):UpdatablePersonPtr {.dynlib:libpath, importc:"new_updatable_person".}
proc new*(_:type UpdatablePerson, id:int, name:string):UpdatablePerson = UpdatablePerson(rawPtr:newUpdatablePerson(id, name.cstring))

proc getUpdatablePersonId(self:UpdatablePersonPtr):int64 {.dynlib:libpath, importc:"get_updatable_person_id".}
proc id*(self:UpdatablePerson):int = self.rawPtr.getUpdatablePersonId().int

proc setUpdatablePersonId(self:UpdatablePersonPtr, id:int) {.dynlib:libpath, importc:"set_updatable_person_id".}
proc setId*(self:UpdatablePerson, id:int) = self.rawPtr.setUpdatablePersonId(id)

proc getUpdatablePersonName(self:UpdatablePersonPtr):cstring {.dynlib:libpath, importc:"get_updatable_person_name".}
proc name*(self:UpdatablePerson):string = $self.rawPtr.getUpdatablePersonName()

proc setUpdatablePersonName(self:UpdatablePersonPtr, name:cstring) {.dynlib:libpath, importc:"set_updatable_person_name".}
proc setName*(self:UpdatablePerson, name:string) = self.rawPtr.setUpdatablePersonName(name.cstring)
```

å‘¼ã³å‡ºã—ã¾ã™ã€‚

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "object":
  test "updatable person":
    let person = UpdatablePerson.new(1, "John")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 1
      person.name() == "John"

    person.setId(2)
    person.setName("Paul")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 2
      person.name() == "Paul"
```
```sh:output
[Suite] object
UpdatablePerson(rawPtr: UpdatablePersonPtr(id: 1, name: "John"))
1
John
UpdatablePerson(rawPtr: UpdatablePersonPtr(id: 2, name: "Paul"))
2
Paul
  [OK] updatable person
```

ã‚»ãƒƒã‚¿ãƒ¼ã‚’ä½¿ã£ã¦ã‚‚ä¸Šæ‰‹ãå‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

## Rustã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ã†
ã“ã‚Œã¾ã§ã¯ç‹¬è‡ªã«å®Ÿè£…ã—ãŸå‡¦ç†ã‚’å‘¼ã³å‡ºã—ã¦ãã¾ã—ãŸãŒã€æœ¬å½“ã«ã‚„ã‚ŠãŸã„ã“ã¨ã¯Rustã«ã‚ã‚‹è±Šå¯Œãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®è³‡ç”£ã‚’Nimã‹ã‚‰ä½¿ã†ã“ã¨ã§ã™ã€‚
ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³é ˜åŸŸã§ä½¿ã‚ã‚Œã‚‹æ¥•å††æ›²ç·šæš—å·ã‚’å®Ÿè£…ã—ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’Nimã‹ã‚‰å‘¼ã³å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

https://docs.rs/p256/latest/p256/

### ç§˜å¯†éµã‚’ä½œã‚‹
Ethereumã§ä½¿ã‚ã‚Œã‚‹ç§˜å¯†éµã¨ã¯0ã€œ255ã¾ã§ã®æ•°å­—ï¼ˆ8bitï¼‰ãŒ32å€‹ä¸¦ã‚“ã ã€256bitï¼ˆ32byteï¼‰ã®ä¹±æ•°ã§ã™ã€‚

https://www.etarou.work/posts/5084927/

#### Rustå´
```sh
cargo add p256 rand_core hex
```

```rust:submods/crypto.rs
use hex::decode as hex_decode;
use hex::encode as hex_encode;
use p256::ecdsa::signature::{Signer, Verifier};
use p256::ecdsa::{Signature, SigningKey, VerifyingKey};
use rand_core::OsRng;
use std::ffi::c_char;

use crate::submods::c_ffi::{cstirng_to_string, string_to_cstring};

#[no_mangle]
pub extern "C" fn create_secret_key() -> *mut Vec<u8> {
    let secret_key: SigningKey<NistP256> = SigningKey::random(&mut OsRng);
    let v: Vec<u8> = secret_key.to_bytes().to_vec();
    Box::into_raw(Box::new(v))
}

#[no_mangle]
pub extern "C" fn get_secret_key_len(v: &mut Vec<u8>) -> usize {
    v.len()
}

#[no_mangle]
pub extern "C" fn get_secret_key_item(v: &mut Vec<u8>, offset: usize) -> u8 {
    v[offset]
}
```

ç§˜å¯†éµã¯8bitã®æ•°å­—ãŒ32å€‹ä¸¦ã‚“ã é…åˆ—ã§ã™ã€‚ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã®ä¾‹ã¨åŒã˜ã‚ˆã†ã«ã€`Vector`ã®ãƒã‚¤ãƒ³ã‚¿ã¨ã—ã¦Nimã«æ¸¡ã—ã€é•·ã•ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰å˜ä½“ã®å€¤ã‚’å–ã‚Šå‡ºã—Nimå´ã§ã¯`Seq`ã¨ã—ã¦å¾©å…ƒã—ã¾ã™ã€‚

#### Nimå´
```nim:rustlib.nim
type SecretKey = ptr object

proc createSecretKeyLib():SecretKey {.dynlib:libpath, importc:"create_secret_key".}
proc len(self:SecretKey):int {.dynlib:libpath, importc:"get_secret_key_len".}
proc `[]`(self:SecretKey, offset:int):uint8 {.dynlib:libpath, importc:"get_secret_key_item".}
proc createSecretKey*():seq[uint8] =
  let secretKey = createSecretKeyLib()
  defer: secretKey.dealloc()
  var s = newSeq[uint8](secretKey.len())
  for i in 0..<secretKey.len().int:
    s[i] = secretKey[i]
  return s
```

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "crypto":
  test "secret key":
    let secretKey = createSecretKey()
    echo secretKey
```

```output

[Suite] crypto
@[39, 234, 215, 165, 187, 41, 126, 106, 147, 128, 126, 120, 235, 187, 243, 63, 97, 84, 236, 27, 126, 195, 100, 93, 40, 90, 142, 186, 63, 11, 152, 44]
  [OK] secret key
```

### ç§˜å¯†éµã‚’ä½œã‚‹2
ç§˜å¯†éµã¯é€šå¸¸ã€`0x`ã‹ã‚‰å§‹ã¾ã‚‹16é€²æ•°ã®æ–‡å­—åˆ—ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ã®ã§ã€ãã®å½¢ã§å‡ºåŠ›ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

```rust:submods/crypto.rs
#[no_mangle]
pub extern "C" fn create_secret_key_hex() -> *mut c_char {
    let secret_key: SigningKey<NistP256> = SigningKey::random(&mut OsRng);
    let bytes: GenericArray<u8, {unknown}.> = secret_key.to_bytes();
    let slices: &[u8] = bytes.as_slice();
    let hex_str: String = hex_encode(&slices);
    string_to_cstring(hex_str)
}
```

#### Nimå´
```nim:rustlib.nim
proc createSecretKeyHexLib():cstring {.dynlib:libpath, importc:"create_secret_key_hex".}
proc createSecretKeyHex*():string = "0x" & $createSecretKeyHexLib()
```
`createSecretKeyHex`é–¢æ•°ã§å…ˆé ­ã«`0x`ã‚’ä»˜ã‘ã¦ã„ã¾ã™ã€‚

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "crypto":
  test "hex key":
    let key = createSecretKeyHex()
    echo key
```

```output
0xa44401854dad16e2f56bd8e637a550f6c0904393ac6cb4286e4e3dc5ebf4f3ed
  [OK] hex key
```

å‡ºåŠ›ã•ã‚Œã¾ã—ãŸã€‚

### ç½²åã—ã¦ã€ç½²åã‚’æ¤œè¨¼ã™ã‚‹
ç½²åã¨ã¯ã€ã‚ã‚‹æ–‡ç« ãŒã‚ã‚‹ç§˜å¯†éµã§æš—å·åŒ–ã•ã‚ŒãŸã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§ã™ã€‚
ç§˜å¯†éµã§æš—å·åŒ–ã•ã‚ŒãŸæ–‡ç« ã¯åŒã˜ç§˜å¯†éµã‹ã‚‰ä½œã‚‰ã‚ŒãŸå…¬é–‹éµã§ã—ã‹è¤‡åˆã§ãã¾ã›ã‚“ã€‚
ãã®æ–‡ç« ãŒæœ¬å½“ã«ãã®ç§˜å¯†éµã‚’æŒã¤äººã«ã‚ˆã£ã¦æš—å·åŒ–ã•ã‚ŒãŸã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã¨ã„ã„ã¾ã™ã€‚

https://www.jipdec.or.jp/project/research/why-e-signature/public-key-cryptography.html

#### Rustå´
ç§˜å¯†éµã‹ã‚‰å…¬é–‹éµã‚’ä½œã‚‹é–¢æ•°ã€ç½²åã™ã‚‹é–¢æ•°ã€æ¤œè¨¼ã™ã‚‹é–¢æ•°ã®3ã¤ã‚’ä½œã‚Šã¾ã™ã€‚
1. ç§˜å¯†éµã‚’ä½¿ã£ã¦æ–‡ç« ã‚’ç½²åã™ã‚‹
2. ç§˜å¯†éµã‹ã‚‰å…¬é–‹éµã‚’ä½œã‚‹
3. å…¬é–‹éµã¨å…ƒã®æ–‡ç« ã€ç½²åã‹ã‚‰ä½œã‚‰ã‚ŒãŸãƒãƒƒã‚·ãƒ¥ã‹ã‚‰ç½²åã‚’æ¤œè¨¼ã™ã‚‹
ã¨ã„ã†æµã‚Œã«ãªã‚Šã¾ã™ã€‚

```rust:submods/crypto.rs
#[no_mangle]
pub extern "C" fn create_verifying_key(_secret_key: &mut c_char) -> *mut c_char {
    let str_secret_key: String = cstirng_to_string(_secret_key);
    let b_key: &Vec<u8> = &(hex_decode(str_secret_key).unwrap());
    let signing_key: SigningKey<NistP256> = SigningKey::from_bytes(b_key).unwrap();
    let verifying_key: VerifyingKey<NistP256> = signing_key.verifying_key();
    let encoded_point: EncodedPoint<{unknown}> = verifying_key.to_encoded_point(true);
    let str_signature: Stirng = encoded_point.to_string();
    string_to_cstring(str_signature)
}

#[no_mangle]
pub extern "C" fn sign_message(_secret_key: &mut c_char, _msg: &mut c_char) -> *mut c_char {
    let str_secret_key: String = cstirng_to_string(_secret_key);
    let b_key: &Vec<u8> = &(hex_decode(str_secret_key).unwrap());
    let signing_key: SigningKey<NistP256> = SigningKey::from_bytes(b_key).unwrap();

    let msg: String = cstirng_to_string(_msg);
    let b_msg: &[u8] = msg.as_bytes();

    let verifying_key: Signature<NistP256> = signing_key.sign(b_msg);
    let str_signature: String = verifying_key.to_string().to_lowercase();
    string_to_cstring(str_signature)
}

#[no_mangle]
pub extern "C" fn verify_sign(
    _verifying_key: &mut c_char,
    _msg: &mut c_char,
    _signature: &mut c_char,
) -> bool {
    let str_verifying_key: String = cstirng_to_string(_verifying_key);
    let b_key: &Vec<u8> = &(hex_decode(str_verifying_key).unwrap());
    let slice_b_key: &[u8] = b_key.as_slice();
    let verifying_key: VerifyingKey<Nist256> = match VerifyingKey::from_sec1_bytes(slice_b_key) {
        Ok(verifying_key: VerifyingKey<Nist256>) => verifying_key,
        Err(_e: Error) => return false,
    };

    let msg: String = cstirng_to_string(_msg);
    let b_msg: &[u8] = msg.as_bytes();

    let str_signature: String = cstirng_to_string(_signature);
    let vec_signature: Vec<u8> = hex_decode(str_signature).unwrap();
    let b_signature: &[u8] = vec_signature.as_slice();
    let signature: Signature<Nist256> = match Signature::try_from(b_signature) {
        Ok(signature: Signature<Nist256>) => signature,
        Err(_e: Error) => return false,
    };

    verifying_key.verify(b_msg, &signature).is_ok()
}
```

#### Nimå´
```nim:rustlib.nim
proc createVerifyingKeyLib(secret:cstring):cstring {.dynlib:libpath, importc:"create_verifying_key".}
proc createVerifyingKey*(secret:string):string =
  let secret = secret[2..^1] # å…ˆé ­ã®0xã‚’å‰Šé™¤
  return "0x" & $createVerifyingKeyLib(secret.cstring)

proc signMessageLib(key, msg:cstring):cstring {.dynlib:libpath, importc:"sign_message".}
proc signMessage*(key, msg:string):string =
  let key = key[2..^1] # å…ˆé ­ã®0xã‚’å‰Šé™¤
  return "0x" & $signMessageLib(key.cstring, msg.cstring)

proc verifySignLib(verifyKey, msg, signature:cstring):bool {.dynlib: libpath, importc:"verify_sign".}
proc verifySign*(verifyKey, msg, signature:string):bool =
  let verifyKey = verifyKey[2..^1 ]# å…ˆé ­ã®0xã‚’å‰Šé™¤
  let signature = signature[2..^1] # å…ˆé ­ã®0xã‚’å‰Šé™¤
  return verifySignLib(verifyKey.cstring, msg.cstring, signature.cstring)
```

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "crypto":
  test "verifying key":
    let secret = createSecretKeyHex()
    echo "=== secret key"
    echo secret
    echo "=== verify key"
    echo createVerifyingKey(secret)

  test "sign message":
    let msg = "Hello World"
    let secretKey = createSecretKeyHex()
    let signature = signMessage(secretKey, msg)
    echo "=== signature"
    echo signature
    let verifyKey = createVerifyingKey(secretKey)
    echo "=== verify key"
    echo verifyKey
    let isValid = verifySign(verifyKey, msg, signature)
    echo "=== expect true"
    echo isValid
    check isValid

  test "wrong message":
    let msg = "Hello World"
    let secret = createSecretKeyHex()
    let signature = signMessage(secret, msg)
    echo "=== signature"
    echo signature
    let verifyKey = createVerifyingKey(secret)
    echo "=== verify key"
    echo verifyKey
    let res = verifySign(verifyKey, "wrong hello", signature)
    echo "=== expect false"
    echo res
    check res == false

  test "wrong signature":
    let msg = "Hello World"
    let secret = createSecretKeyHex()
    let signature = signMessage(secret, msg)
    echo "=== signature"
    echo signature
    var expectWrong = verifySign("0x012345abcdef", msg, signature)
    echo "=== expect false"
    echo expectWrong
    check expectWrong == false
```

```sh:output
=== secret key
0x61ee88fb30fe88e1bd0bafae57f78811c678b58a55401c5e64c714f8907da3a6
=== verify key
0x035C687146BF98F3935AA4E0B267522765ED7C15B17FC08372E115869D92922615
  [OK] verifying key

=== signature
0xf1f6bbe1345faaa3c3514b6ca01324602d9ab0344b38439574fda2b70a3c092462ffef099a068126aa8764637f9efce89554a94018f7c56d2f26210b120da33d
=== verify key
0x03EB937AF6C821116418A7BEF874974BED79ED43AC39B2D5CE28802C1971AC3BBC
=== expect true
true
  [OK] sign message

=== signature
0x606bb9b3b9094057aadc2f4563923fdfc6d4a73f6991e530e3e60fc346c2d4245c2544be8dabb0535fe8cab0b8119b8920cf89a44e5f518bbe4f5c86b435be5a
=== verify key
0x0253FF110C708A36E15F18B4784E48473B3EC74485CD1E6D0AA989580CEF4F65CF
=== expect false
false
  [OK] wrong message

=== signature
0xb83a17ac892234b3b840c8d45cd2a8e1d4b68601d2a3dc52cad4fa86c13116150cc8288b0ffed750e0af45cd8d600875b06b1db0c4f7077828927b3d34155433
=== expect false
false
  [OK] wrong signature
```

æ­£ã—ãç½²åã®æ¤œè¨¼ãŒã§ãã¾ã—ãŸã€‚

## ãŠã‚ã‚Šã«
Nimã¨Rustã®FFIã®æ©Ÿèƒ½ã‚’ä½¿ã£ã¦ç›¸äº’ã«å€¤ã‚’ã‚„ã‚Šã¨ã‚Šã§ãã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚
ã“ã‚Œã§Nimã§Rustã®è³‡ç”£ãŒä½¿ãˆã¾ã™ï¼ **ã©ã—ã©ã—Nimã§Rustã‚’ãƒ©ãƒƒãƒ—ã—ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½œã‚Šã€Nimã§ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã£ã¦ã„ãã¾ã—ã‚‡ã†ï¼ï¼ï¼**

æ„Ÿæƒ³ã¨ã—ã¦ã¯ã€FFIã‚’ã™ã‚‹ãŸã‚ã®Rustå´ã§ã®å‹ãƒ‘ã‚ºãƒ«ã€ãƒã‚¤ãƒ³ã‚¿ã¯Nimå´ã§æ˜ç¤ºçš„ã«é–‹æ”¾ã—ãªã‘ã‚Œã°ã„ã‘ãªã„ã“ã¨ãŒå°‘ã—é›£ã—ã„ã‹ãªã¨æ€ã„ã¾ã—ãŸã€‚
æ•°å€¤å´ã‚„boolã¯ã»ã¼ãã®ã¾ã¾ã§å¤§ä¸ˆå¤«ãªã‚“ã§ã™ãŒã€ãƒ’ãƒ¼ãƒ—ã«ç©ã¾ã‚Œã‚‹æ–‡å­—åˆ—ã€é…åˆ—ã€ç‹¬è‡ªå‹ã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ã™ã‚‹ã¨æ‰±ãˆã‚‹ã‚ˆã†ã§ã™ã€‚

|å‹|Nimã®å¼•æ•°|Nimã®è¿”ã‚Šå€¤|Rustã®å¼•æ•°|Rustã®è¿”ã‚Šå€¤|
|---|---|---|---|---|
|æ–‡å­—åˆ—|cstring|cstring|&mut c_char|*mut c_char / *const c_char|
|é…åˆ—|type T = ptr object|type T = ptr object|&mut Vec<T>|*mut Vec<T>|
|ç‹¬è‡ªå‹|type T = ptr object|type T = ptr object|&T / &mut T|*mut T|

ã¾ãŸRustã«FFIã‚’æ¥½ã«ã™ã‚‹[`safer_ffi`](https://github.com/getditto/safer_ffi)ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã‚ã‚Šã€ãã¡ã‚‰ã‚‚ä½¿ã£ã¦ã¿ã¾ã—ãŸãŒã€ã¾ã ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒæœªç†Ÿãªã‚ˆã†ã§ã€Rustã®é–¢æ•°ã§å¼•æ•°ã‚’å—ã‘å–ã‚‹ã“ã¨ãŒã§ããªã‹ã£ãŸã‚Šã—ã¾ã—ãŸã€‚
ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã¡ã‚ƒã‚“ã¨ä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚‹ã¨ã€Rustã®é–¢æ•°ã‹ã‚‰Cã®ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡ºåŠ›ã—ã€Cã®ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰[c2nim](https://github.com/nim-lang/c2nim)ã‚’ä½¿ã£ã¦Nimã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹é–¢æ•°ã‚’è‡ªå‹•ç”Ÿæˆã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã®ã§ã€ä»Šå¾Œã®ç™ºå±•ã«æœŸå¾…ã—ã¦ã„ããŸã„ã§ã™ã€‚
