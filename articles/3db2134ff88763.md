---
title: "Rustã‚’Nimã‹ã‚‰å‘¼ã³å‡ºã™"
emoji: "ğŸ‘‘"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [
  "nim", "rust"
]
published: false
---

## ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³
Nimã¯Pythonã®ã‚ˆã†ãªç°¡å˜ãªæ–‡æ³•ã§ã€Cè¨€èªã«ãƒˆãƒ©ãƒ³ã‚¹ãƒ‘ã‚¤ãƒ«ã—ãƒã‚¤ãƒŠãƒªã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã“ã¨ã§ã€å­¦ç¿’ã‚³ã‚¹ãƒˆã®ä½ã•ã€é–‹ç™ºã®ç”Ÿç”£æ€§ã®é«˜ã•ã€å®Ÿè¡Œé€Ÿåº¦ã®é€Ÿã•ã‚’å…¼ã­æƒãˆãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã™ã€‚
æ‰€æœ‰æ¨©ãƒ»å€Ÿç”¨ã«åŸºã¥ãã‚¹ã‚³ãƒ¼ãƒ—ãƒ™ãƒ¼ã‚¹ã§ã®å®‰å…¨ãªãƒ¡ãƒ¢ãƒªç®¡ç†ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒè‡ªå‹•ã§è¡Œã„ã€Goè¨€èªã®ã‚ˆã†ã«å‚ç…§ã‚„ãƒã‚¤ãƒ³ã‚¿ã«ã¤ã„ã¦è€ƒãˆã‚‹å¿…è¦ã‚‚ãªã„ãŸã‚ã€ç‰¹ã«ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã«ãŠã„ã¦ã€Œã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã®ãŸã‚ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚’æ¸›ã‚‰ã›ã¦ãã®è¨˜è¿°ã‚’ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã ã‘ã«é›†ä¸­ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã—ã‹ã—ã¾ã æ™®åŠã—ã¦ã„ã‚‹ã¨ã¯è¨€ã„é›£ãã€ä½¿ã‚ãªã„äººã®æ„è¦‹ã‚’èãã¨ã€Œãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå°‘ãªã„ã€ã¨ã„ã†ç†ç”±ã‚’å¤šãèãã¾ã™ã€‚
Nimã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ä¸€æ—¦Cè¨€èªã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ã€æ—¢ã«Cè¨€èªã§å­˜åœ¨ã—ã¦ã„ã‚‹è³‡ç”£ã‚’ç°¡å˜ã«å–ã‚Šè¾¼ã‚€ã“ã¨ãŒã§ãã€å‹•çš„ãƒªãƒ³ã‚¯ãƒ»é™çš„ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ä¸¡æ–¹ã¨éå¸¸ã«ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã«é€£æºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä¸€æ–¹ã§Rustã¯ä½ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãŠã‘ã‚‹ãƒ¡ãƒ¢ãƒªå®‰å…¨ã‚’å¾¹åº•ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã€ã‚»ã‚°ãƒ•ã‚©ã‚„ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’é˜²ãéå¸¸ã«é«˜é€Ÿã«å‹•ä½œã—ã¾ã™ã€‚
ã—ã‹ã—å¤‰æ•°ã®æ‰€æœ‰æ¨©ã‚„å€Ÿç”¨ã‚’é–‹ç™ºæ™‚ã«è€ƒæ…®ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ã¨ã¦ã‚‚å­¦ç¿’ã‚³ã‚¹ãƒˆãŒé«˜ã„ã§ã™ã€‚å°‘ãªãã¨ã‚‚æ–‡ç³»å‡ºèº«2å¹´ç›®PHPerãŒç°¡å˜ã«æ‰±ãˆã‚‹ã‚ˆã†ãªè¨€èªã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ã“ã®2ã¤ã®è¨€èªã®ç‰¹å¾´ã‚’è€ƒãˆãŸæ™‚ã«ã€æ•°å­¦ã«åŸºã¥ãã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…ãªã©ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯Rustã§ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯Nimã§ä½œã‚‹ã¨ä¸¡è€…ã®ã„ã„ã¨ã“å–ã‚ŠãŒã§ãã‚‹ã®ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ã€‚

Nimã€Rustä¸¡æ–¹å…±ã«Cè¨€èªã‚’ä»‹ã—ãŸFFIã®æ©Ÿæ§‹ãŒå‚™ã‚ã£ã¦ã„ã‚‹ãŸã‚ã€ä»Šå›ã¯ãã‚Œã‚’ä½¿ã£ã¦Rustã§ä½œã£ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’Nimã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰å‘¼ã¶å®Ÿé¨“ã‚’ã—ã¾ã™ã€‚

## ç’°å¢ƒæ§‹ç¯‰
Nimã¨Rustä¸¡æ–¹ã®ç’°å¢ƒãŒå…¥ã£ãŸDockerã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œã‚Šã¾ã™ã€‚

```dockerfile
FROM ubuntu:22.04

# prevent timezone dialogue
ENV DEBIAN_FRONTEND=noninteractive

RUN apt update --fix-missing && \
    apt upgrade -y
RUN apt install -y --fix-missing \
        gcc \
        xz-utils \
        ca-certificates \
        curl \
        pkg-config

WORKDIR /root
# ==================== Nim ====================
RUN curl https://nim-lang.org/choosenim/init.sh -sSf | sh -s -- -y
ENV PATH $PATH:/root/.nimble/bin

# ==================== Rust ====================
RUN curl https://sh.rustup.rs -sSf | sh -s -- -y

WORKDIR /application
```

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
`/application`é…ä¸‹ã«`src`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œã‚Šãã“ã§ä½œæ¥­ã—ã¾ã™ã€‚


Nimã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹
```sh
cd /application/src
nimble init nimapp
```
å¯¾è©±å‹ã§èã‹ã‚Œã‚‹ã®ã§ã€é¸æŠè‚¢ã‚’Tabã§ã‚µã‚¤ã‚¯ãƒ«ã—ã¦Enterã§é¸ã³ã¾ã™ã€‚
`Package type?`ã§ã¯`Binary`ã‚’é¸ã³ã¾ã™ã€‚

```sh
  Info: Package initialisation requires info which could not be inferred.
    ... Default values are shown in square brackets, press
    ... enter to use them.
  Using "nimapp" for new package name
Prompt: Your name? [Anonymous]

Answer:       Using "src" for new package source directory
Prompt: Package type?
    ... Library - provides functionality for other packages.
    ... Binary  - produces an executable for the end-user.
    ... Hybrid  - combination of library and binary
    ... For more information see https://goo.gl/cm2RX5
  Select Cycle with 'Tab', 'Enter' when done
Answer: binary
Prompt: Initial version of package? [0.1.0]

Answer:     Prompt: Package description? [A new awesome nimble package]

Answer:     Prompt: Package License?
    ... This should ideally be a valid SPDX identifier. See https://spdx.org/licenses/.
  Select Cycle with 'Tab', 'Enter' when done
Answer: MIT
Prompt: Lowest supported Nim version? [1.6.10]

Answer:    Success: Package nimapp created successfully
```


Rustã§ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã‚‹
```sh
cd /application/src
cargo new rustlib --lib
```

ã“ã†ã„ã†ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã«ãªã‚Šã¾ã™

```
/application
`-- src
    |-- nimapp
    |   |-- nimapp.nimble
    |   |-- src
    |   |   `-- nimapp.nim
    |   `-- tests
    |       |-- config.nims
    |       `-- test1.nim
    `-- rustlib
        |-- Cargo.toml
        `-- src
            `-- lib.rs
```


## é–¢æ•°ã‚’å‘¼ã¶
ã¾ãšã¯ç°¡å˜ãªã€intã‚’è¶³ã—ç®—ã™ã‚‹addé–¢æ•°ã‚’ä½œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### Rustå´

```rust:lib.rs
#[no_mangle]
pub extern "C" fn add(a: i64, b: i64) -> i64 {
    return a + b;
}
```

```
#[no_mangle]
```
ã“ã‚Œã‚’é–¢æ•°ã«å¯¾ã—ã¦ä»˜ã‘ã‚‹ã“ã¨ã§ã€C/Nimã‹ã‚‰ã€Rustã§å®šç¾©ã—ãŸé€šã‚Šã®`add`ã®é–¢æ•°åã§å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```rs
pub extern "C"
```
é–¢æ•°ã«å¯¾ã—ã¦ã“ã‚Œã‚’ä»˜ã‘ã‚‹ã“ã¨ã§ã€C/Nimã‹ã‚‰å‘¼ã³å‡ºã›ã‚‹é–¢æ•°ã«ãªã‚Šã¾ã™ã€‚

https://tomoyuki-nakabayashi.github.io/book/interoperability/rust-with-c.html#c-api%E3%81%AE%E4%BD%9C%E6%88%90


ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å‡ºåŠ›ã™ã‚‹æ™‚ã«ã¯ã€`crate-type`ã‚’è¨­å®šã—ã¾ã™ã€‚
å‹•çš„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ™‚ã«ã¯`cdylib`ã‚’ã€é™çš„ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ™‚ã«ã¯`staticlib`ã«ã—ã¾ã™ã€‚

```toml:Cargo.toml
[package]
name = "rustlib"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name         = "rustlib"
crate-type   = ["cdylib"]
# crate-type   = ["staticlib"]
```

https://qiita.com/etoilevi/items/4bd4c5b726e41f5a6689


ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚
```sh
cd /application/src/rustlib
cargo build --release
```
`/application/src/rustlib/target/release/librustlib.so`ã«Shard Objectãƒ•ã‚¡ã‚¤ãƒ«ãŒå‡ºåŠ›ã•ã‚Œã¾ã—ãŸã€‚ã“ã‚Œã‚’Nimã‹ã‚‰å‘¼ã³å‡ºã—ã¦ä½¿ã„ã¾ã™ã€‚

### Nimå´
`/application/src/nimapp/src/rustlib.nim`ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚Šã€Shard Objectã«ã‚ã‚‹é–¢æ•°ã‚’Nimã‹ã‚‰å‘¼ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®ã‚°ãƒ«ãƒ¼é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚

```nim:rustlib.nim
const libpath = "/application/src/rustlib/target/release/librustlib.so"

proc add*(a, b:int64):int64 {.dynlib:libpath, importc: "add".}
```

ã‚ã¨ã¯`nimapp.nim`ã‹ã‚‰ã“ã®`add`é–¢æ•°ã‚’å‘¼ã³å‡ºã›ã°ã„ã„ã ã‘ã§ã™ã€‚
```nim:nimapp.nim
import std/unittest
import ./rustlib

suite "test":
  test "add":
    echo add(1, 2)
    check add(1, 2) == 3
```

å®Ÿè¡Œã—ã¾ã—ã‚‡ã†ã€‚
```sh
cd /application/src/nimapp
nim c -r -f --mm:orc src/nimapp
```
```sh:output
[Suite] test
3
  [OK] add
```

å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

## å‹•çš„é…åˆ—ã‚’æ‰±ã†
Rustã®Vectorã‚’Nimã§æ‰±ã†ã«ã¯ã©ã†ã™ã‚Œã°ã„ã„ã§ã—ã‚‡ã†ã‹ã€‚
ã“ã“ã§ã¯ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’è¿”ã™é–¢æ•°ã‚’ä½¿ã£ã¦èª¬æ˜ã—ã¾ã™ã€‚

### Rustå´
ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°ã‚’è¿”ã™é–¢æ•°ã€ãã‚Œã‚’å†…éƒ¨ã§å‘¼ã‚“ã§ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’è¿”ã™é–¢æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚

```rust:lib.rs
#[no_mangle]
fn fib(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 2) + fib(n - 1),
    }
}

#[no_mangle]
pub extern "C" fn fib_array(n: u64) -> *mut Vec<u64> {
    let mut vector = Vec::with_capacity(n.try_into().unwrap());
    for i in 0..n {
        vector.push(fib(i));
    }
    Box::into_raw(Box::new(vector))
}

#[no_mangle]
pub extern "C" fn get_vector_len(v: &Vec<u64>) -> usize {
    v.len()
}

#[no_mangle]
pub extern "C" fn get_vector_item(v: &Vec<u64>, offset: usize) -> u64 {
    v[offset]
}
```

fib_arrayã®è¿”ã‚Šå€¤ã®å‹ã¯`*mut Vec<u64>`ã«ã—ã€é–¢æ•°ã®æœ€å¾Œã§`Box::into_raw(Box::new(vector))`ã‚’å‘¼ã‚“ã§ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ã«ã—ã¦è¿”ã—ã¾ã™ã€‚
æ›´ã«Vectorã‹ã‚‰é•·ã•ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆä½ç½®ã®å€¤ã‚’è¿”ã™é–¢æ•°ã‚‚å®Ÿè£…ã—ã¾ã™ã€‚

### Nimå´

```nim:rustlib.nim
type VectorPtr = ptr object

proc fibArrayLib(n:int):VectorPtr {.dynlib:libpath, importc: "fib_array".}
proc len(self:VectorPtr):int {.dynlib:libpath, importc: "get_vector_len".}
proc `[]`(self:VectorPtr, offset:int):int {.dynlib:libpath, importc: "get_vector_item".}
proc fibArray*(n:int):seq[int] =
  let v = fibArrayLib(n)
  defer: v.dealloc()
  var s = newSeq[int](n)
  for i in 0..<v.len:
    s[i] = v[i]
  return s
```

Rustã®`get_vector_len`ã®è¿”ã‚Šå€¤ã¯ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ãªã®ã§ã€ãã‚Œã‚’ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ãŸã‚ã®ç‹¬è‡ªã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’`VectorPtr`ã¨ã—ã¦å®šç¾©ã—ã¾ã™ã€‚
Nimã®é–¢æ•°ã¯å…¨ã¦é™çš„ãªå‹ãƒã‚§ãƒƒã‚¯ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦å‹•ãã®ã§ã€ã“ã“ã§å®šç¾©ã—ãŸé–¢æ•°ã¯å…¨ã¦`VectorPtr`ã®å‹ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦ã®ã¿å‹•ãã¾ã™ã€‚
`fibArray`é–¢æ•°ã®ä¸­ã§Rustå´ã§å®šç¾©ã—ãŸé–¢æ•°ãŸã¡ã‚’å‘¼ã³ã€ç”Ÿãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰Vectorã®é•·ã•ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆä½ç½®ã®å€¤ã‚’å–å¾—ã—ã€Nimã®å‹•çš„é…åˆ—ã§ã‚ã‚‹Seq(Sequence)ã«è©°ã‚æ›¿ãˆã¦è¿”ã—ã¦ã„ã¾ã™ã€‚
Nimã§ã¯ç”Ÿãƒã‚¤ãƒ³ã‚¿ã¯Nimã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã®ç®¡è½„å¤–ã«ãªã‚Šã¾ã™ã€‚ç”Ÿãƒã‚¤ãƒ³ã‚¿ã®ãƒ¡ãƒ¢ãƒªã‚’é–‹æ”¾ã™ã‚‹`dealloc`é–¢æ•°ãŒç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€`defer`ã‚’ä½¿ã£ã¦ã‚¹ã‚³ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹ã¨ãƒ¡ãƒ¢ãƒªãŒé–‹æ”¾ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ã“ã®`defer`ã¯Goè¨€èªã¨åŒã˜ã§ã™ã€‚

ã§ã¯`nimapp`ã®ä¸­ã§å‘¼ã³å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "test":
  test "add":
    echo add(1, 2)
    check add(1, 2) == 3

  test "fib array":
    let res = fibArray(10)
    echo res
    check res == @[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

```sh
cd /application/src/nimapp
nim c -r -f --mm:orc src/nimapp
```
```sh:output
[Suite] test
3
  [OK] add
@[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
  [OK] fib array
```

å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã—ãŸã€‚


:::message
## å‡¦ç†ã‚’ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ç§»å‹•ã•ã›ã‚‹
ã“ã“ã¾ã§addé–¢æ•°ã¨ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã‚’å‡ºåŠ›ã™ã‚‹é–¢æ•°ã‚’`lib.rs`ã«æ›¸ã„ã¦ãã¾ã—ãŸãŒã€ã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ç§»ã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚
ãã®æ–¹ãŒã‚³ãƒ¼ãƒ‰ã®è¦‹é€šã—ãŒã‚ˆããªã‚‹ã®ã§ã€ç§»ã—ã¾ã—ã‚‡ã†ã€‚

Rustã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’ã“ã®ã‚ˆã†ã«ã—ã¾ã™ã€‚

```
.
|-- Cargo.lock
|-- Cargo.toml
`-- src
    |-- lib.rs
    `-- submods
        `-- fib.rs
```

fib.rsã«å‡¦ç†ã‚’ç§»å‹•ã•ã›ã¾ã™ã€‚
```rust:submods/fib.rs
fn fib(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 2) + fib(n - 1),
    }
}

#[no_mangle]
pub extern "C" fn fib_array(n: u64) -> *mut Vec<u64> {
    let mut vector = Vec::with_capacity(n.try_into().unwrap());
    for i in 0..n {
        vector.push(fib(i));
    }
    Box::into_raw(Box::new(vector))
}

#[no_mangle]
pub extern "C" fn get_vector_len(v: &Vec<u64>) -> usize {
    v.len()
}

#[no_mangle]
pub extern "C" fn get_vector_item(v: &Vec<u64>, offset: usize) -> u64 {
    v[offset]
}
```

lib.rsã¯ã“ã®ã‚ˆã†ã«ã—ã¾ã™
```rust:lib.rs
mod submods {
    pub mod fib;
}

#[no_mangle]
pub extern "C" fn add(a: i64, b: i64) -> i64 {
    return a + b;
}
```
:::

## ã‚«ã‚¹ã‚¿ãƒ å‹ï¼ˆç‹¬è‡ªå‹ã€æ§‹é€ ä½“ï¼‰ã‚’æ‰±ã†
Rustã®ä¸­ã§å®šç¾©ã—ãŸæ§‹é€ ä½“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’Nimã‹ã‚‰æ‰±ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

### Rustå´
`submods/person.rs`ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚Šã¾ã™ã€‚
æ•°å€¤ã¨æ–‡å­—åˆ—ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤`Person`å‹ã¨ã€ãã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ã‚²ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¾ã™ã€‚
FFIã«å‡ºåŠ›ã™ã‚‹é–¢æ•°åã¯ãªã‚‹ã¹ãè¢«ã‚‰ãªã„ã‚ˆã†ãªå‘½åã«ã—ãŸæ–¹ãŒã„ã„ã§ã—ã‚‡ã†ã€‚ãã®ãŸã‚ãŸã idã‚’è¿”ã™ãƒ¡ã‚½ãƒƒãƒ‰åã‚‚`id`ã§ã¯ãªã`get_person_id`ã¨ã—ã¦ã„ã¾ã™ã€‚

```diff rust:lib.rs
  mod submods {
      pub mod fib;
+     pub mod c_ffi;
+     pub mod person;
  }

+ use crate::submods::c_ffi;

  #[no_mangle]
  pub extern "C" fn add(a: i64, b: i64) -> i64 {
      return a + b;
  }
```

```rust:submods/person.rs
use std::ffi::c_char;
use crate::c_ffi;


pub struct Person {
    id: i64,
    name: String,
}

impl Person {
    pub fn new(id: i64, name: String) -> Box<Person> {
        let person = Box::new(Person { id, name });
        person
    }

    pub fn id(&self) -> i64 {
        self.id
    }

    pub fn name(&self) -> String {
        self.name.to_string()
    }
}

// ==================== FFI ====================
#[no_mangle]
pub extern "C" fn new_person(id: i64, _name: *const c_char) -> *mut Person {
    let name = c_ffi::cstirng_to_string(_name);
    let person = Person::new(id, name);
    Box::into_raw(person)
}

#[no_mangle]
pub extern "C" fn get_person_id(person: &Person) -> i64 {
    person.id()
}

#[no_mangle]
pub extern "C" fn get_person_name(person: &Person) -> *mut c_char {
    c_ffi::string_to_cstring(person.name())
}

// ==================== test ====================
#[cfg(test)]
mod person_tests {
    use super::*;

    #[test]
    fn person_test() {
        let person = Person::new(1, "John".to_string());
        assert_eq!(person.id(), 1);
        assert_eq!(person.name(), "John");
    }
}
```

`new_person`é–¢æ•°ã®å¼•æ•°nameã®å‹ã¯`*const c_char`ã«ãªã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯Cè¨€èªã®æ–‡å­—åˆ—ã‚’Rustã§æ‰±ã†ãŸã‚ã®å‹ã§ã™ã€‚
åå¯¾ã«Rustâ†’Cè¨€èªã¸æ–‡å­—åˆ—ã‚’è¿”ã™ã«ã¯`*mut c_char`ã«ã—ã¾ã™ã€‚

`new_person`é–¢æ•°ã®è¿”ã‚Šå€¤ã®å‹ã¯`*mut Person`ã§ã™ã€‚ã“ã‚Œã¯å…ˆã»ã©ã®ãƒ•ã‚£ãƒœãƒŠãƒƒãƒæ•°åˆ—ã¨åŒã˜ãã€ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ã«ãªã£ã¦ã„ã¾ã™ã€‚

Nimã®æ–‡å­—åˆ—ã‚‚Rustã®æ–‡å­—åˆ—ã‚‚ãã‚Œãã‚Œã®è¨€èªã®å®Ÿè¡Œç’°å¢ƒã®ä¸­ã§ã¿å‹•ä½œã™ã‚‹ç‹¬è‡ªã®å‹ã§ã™ã€‚
ãã®ãŸã‚Cè¨€èªã‚’ä»‹ã—ã¦Nimã‹ã‚‰Rustã¸æ–‡å­—åˆ—ã‚„ã‚Šã¨ã‚Šã™ã‚‹ãŸã‚ã«ã¯ã€ç›¸äº’ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã“ã§ã¯ã¾ãšRustå´ã«Cè¨€èªã®æ–‡å­—åˆ—ã‚’ç›¸äº’å¤‰æ›ã™ã‚‹é–¢æ•°ã‚’ä½œã‚Šã¾ã—ãŸã€‚

```rust:submods/c_ffi.rs
use std::ffi::c_char;
use std::ffi::CStr;
use std::ffi::CString;

pub fn cstirng_to_string(_arg: *const c_char) -> String {
    let arg = unsafe {
        assert!(!_arg.is_null());
        let c_str = CStr::from_ptr(_arg);
        let str_slice = c_str.to_str().unwrap();
        str_slice.to_owned()
    };
    arg
}

pub fn string_to_cstring(_arg: String) -> *mut c_char {
    CString::new(_arg).unwrap().into_raw()
}
```

`person.rs`ã§ã¯ã“ã‚Œã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚

### Nimå´

```nim:rustlib.nim
type
  PersonObj {.pure, final.} = object
    id:int
    name:cstring

  PersonPtr = ptr PersonObj

  Person* = ref object
    rawPtr: PersonPtr


proc newPerson(id:int, name:cstring):PersonPtr {.dynlib:libpath, importc:"new_person".}
proc new*(_:type Person, id:int, name:string):Person = Person(rawPtr:newPerson(id, name.cstring))

proc getPersonId(self:PersonPtr):int64 {.dynlib:libpath, importc:"get_person_id".}
proc id*(self:Person):int = self.rawPtr.getPersonId().int

proc getPersonName(self:PersonPtr):cstring {.dynlib:libpath, importc:"get_person_name".}
proc name*(self:Person):string = $self.rawPtr.getPersonName()
```

Rustã®æ§‹é€ ä½“å®šç¾©ã¨åŒã˜æ§‹é€ ä½“ã‚’Nimã®objectã§å®šç¾©ã—ã¾ã™ã€‚

å®Ÿéš›ã«Rustã®é–¢æ•°ã¨ã‚„ã‚Šã¨ã‚Šã™ã‚‹ã®ã¯ãƒ’ãƒ¼ãƒ—ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ãªã®ã§ã€ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ãŸã‚ã®ãƒã‚¤ãƒ³ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ`PersonPtr`ã‚’å®šç¾©ã—ã¾ã™ã€‚
ãƒã‚¤ãƒ³ã‚¿ã¯Nimã®ãƒ¡ãƒ¢ãƒªç®¡ç†ã®ç®¡è½„å¤–ã«ãªã‚Šã¾ã™ãŒã€ãƒã‚¤ãƒ³ã‚¿ã®å‹ã‚’ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«æŒã¤`ref`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯è‡ªå‹•ã§ãƒ¡ãƒ¢ãƒªç®¡ç†ã•ã‚Œã‚‹ã®ã§ã€`Person* = ref object`ã‚’å®šç¾©ã—Nimã‹ã‚‰ã¯ã“ã¡ã‚‰ã‚’æ‰±ã†ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Š`dealloc`ä½¿ã£ã¦æ˜ç¤ºçš„ã«ãƒ¡ãƒ¢ãƒªè§£æ”¾ã‚’ã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚

`newPerson`ã®å¼•æ•°nameã®å‹ã¯`cstring`ã§ã™ã€‚ã“ã‚ŒãŒNimã®ä¸­ã§ã®Cè¨€èªã®æ–‡å­—åˆ—ã«ç›¸å½“ã—ã€`"æ–‡å­—åˆ—".cstring`ã¨ã™ã‚Œã°å‹å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

`name`é–¢æ•°ã®ä¸­ã§ã¯`getPersonName`ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ãŒã€`getPersonName`ã®è¿”ã‚Šå€¤ã®å‹ã¯`cstring`ãªã®ã§ã€`$`ã‚’ä»˜ã‘ã¦`string`ã«å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚`$`ã¯Nimã®ä¸–ç•Œã§ã¯ã‚ã‚‰ã‚†ã‚‹å‹ã‚’æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ãƒã‚¸ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚ï¼ˆå®Ÿéš›ã«ã¯å…¨ã¦ã®å‹ã«`$`ã¨ã„ã†åŒåã®é–¢æ•°åã§æ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ã‚ˆã†ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ï¼‰

```nim
proc new*(_:type Person, id:int, name:string):Person = Person(rawPtr:newPerson(id, name.cstring))
proc id*(self:Person):int = self.rawPtr.getPersonId().int
proc name*(self:Person):string = $self.rawPtr.getPersonName()
```
ã“ã®3ã¤ã®é–¢æ•°ã¯Nimã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‹ã‚‰å‘¼ã³å‡ºã•ã‚ŒRustã®é–¢æ•°ã¨ãƒãƒƒãƒ”ãƒ³ã‚°ã—ãŸ`newPerson`ãªã©ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™å‡¦ç†ã¨å‹å¤‰æ›ã‚’è¡Œã†ã‚°ãƒ«ãƒ¼ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚

ã§ã¯å‘¼ã³å‡ºã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```nim:nimapp.nim
suite "object":
  test "person":
    let person = Person.new(1, "John")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 1
      person.name() == "John"
```
```sh:output
[Suite] object
Person(rawPtr: PersonPtr(id: 1, name: "John"))
1
John
  [OK] person
```
`PersonPtr`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®å€¤ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚‚ã€é–¢æ•°å‘¼ã³ã ã—ã‚‚ä¸Šæ‰‹ãè¡Œã£ã¦ã„ã¾ã™ã€‚

## ã‚»ãƒƒã‚¿ãƒ¼ã‚’æŒã¤ç‹¬è‡ªå‹ã‚’æ‰±ã†
ã“ã‚Œã¾ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆã¨ã‚²ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã—ã‹æ‰±ã£ã¦ã„ã¾ã›ã‚“ãŒã€ã‚»ãƒƒã‚¿ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚‚ä¸Šæ‰‹ãã„ãã§ã—ã‚‡ã†ã‹
ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ãŒã§ãã‚‹`UpdatablePerson`å‹ã‚’ä½¿ã£ã¦èª¬æ˜ã—ã¾ã™ã€‚

### Rustå´
```diff rust:lib.rs
  mod submods {
      pub mod fib;
      pub mod c_ffi;
      pub mod person;
+     pub mod updatable_person;
  }

  use crate::submods::c_ffi;

  #[no_mangle]
  pub extern "C" fn add(a: i64, b: i64) -> i64 {
      return a + b;
  }
```

```rust:submods/update_person.rs
use std::ffi::c_char;
use crate::submods::c_ffi;

pub struct UpdatablePerson {
    id: i64,
    name: String,
}

impl UpdatablePerson {
    pub fn new(id: i64, name: String) -> Box<UpdatablePerson> {
        let person = Box::new(UpdatablePerson { id, name });
        person
    }

    pub fn id(&self) -> i64 {
        self.id
    }

    pub fn set_id(&mut self, id: i64) {
        self.id = id
    }

    pub fn name(&self) -> String {
        self.name.to_string()
    }

    pub fn set_name(&mut self, name: String) {
        self.name = name
    }
}


#[no_mangle]
pub extern "C" fn new_updatable_person(id: i64, _name: *const c_char) -> *mut UpdatablePerson {
    let name = c_ffi::cstirng_to_string(_name);
    let person = UpdatablePerson::new(id, name);
    Box::into_raw(person)
}

#[no_mangle]
pub extern "C" fn get_updatable_person_id(person: &UpdatablePerson) -> i64 {
    person.id()
}

#[no_mangle]
pub extern "C" fn set_updatable_person_id(person: &mut UpdatablePerson, id: i64) {
    person.set_id(id)
}

#[no_mangle]
pub extern "C" fn get_updatable_person_name(person: &UpdatablePerson) -> *mut c_char {
    c_ffi::string_to_cstring(person.name())
}

#[no_mangle]
pub extern "C" fn set_updatable_person_name(person: &mut UpdatablePerson, _name: *const c_char) {
    let name = c_ffi::cstirng_to_string(_name);
    person.set_name(name)
}


#[cfg(test)]
mod updatable_person_test {
    use super::*;

    #[test]
    fn test1() {
        let mut person = UpdatablePerson::new(1, "John".to_string());
        assert_eq!(person.id(), 1);
        assert_eq!(person.name(), "John");
        person.set_id(2);
        person.set_name("Paul".to_string());
        assert_eq!(person.id(), 2);
        assert_eq!(person.name(), "Paul");
    }
}
```

### Nimå´
```nim:rustlib.nim
type
  UpdatablePersonObj {.pure, final.} = object
    id:int
    name:cstring

  UpdatablePersonPtr = ptr UpdatablePersonObj

  UpdatablePerson* = ref object
    rawPtr: UpdatablePersonPtr


proc newUpdatablePerson(id:int, name:cstring):UpdatablePersonPtr {.dynlib:libpath, importc:"new_updatable_person".}
proc new*(_:type UpdatablePerson, id:int, name:string):UpdatablePerson = UpdatablePerson(rawPtr:newUpdatablePerson(id, name.cstring))

proc getUpdatablePersonId(self:UpdatablePersonPtr):int64 {.dynlib:libpath, importc:"get_updatable_person_id".}
proc id*(self:UpdatablePerson):int = self.rawPtr.getUpdatablePersonId().int

proc setUpdatablePersonId(self:UpdatablePersonPtr, id:int) {.dynlib:libpath, importc:"set_updatable_person_id".}
proc setId*(self:UpdatablePerson, id:int) = self.rawPtr.setUpdatablePersonId(id)

proc getUpdatablePersonName(self:UpdatablePersonPtr):cstring {.dynlib:libpath, importc:"get_updatable_person_name".}
proc name*(self:UpdatablePerson):string = $self.rawPtr.getUpdatablePersonName()

proc setUpdatablePersonName(self:UpdatablePersonPtr, name:cstring) {.dynlib:libpath, importc:"set_updatable_person_name".}
proc setName*(self:UpdatablePerson, name:string) = self.rawPtr.setUpdatablePersonName(name.cstring)
```

å‘¼ã³å‡ºã—ã¾ã™ã€‚

```nim:nimapp.nim
suite "object":
  test "updatable person":
    let person = UpdatablePerson.new(1, "John")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 1
      person.name() == "John"

    person.setId(2)
    person.setName("Paul")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 2
      person.name() == "Paul"
```
```sh:output
[Suite] object
UpdatablePerson(rawPtr: UpdatablePersonPtr(id: 1, name: "John"))
1
John
UpdatablePerson(rawPtr: UpdatablePersonPtr(id: 2, name: "Paul"))
2
Paul
  [OK] updatable person
```

ã‚»ãƒƒã‚¿ãƒ¼ã‚’ä½¿ã£ã¦ã‚‚ä¸Šæ‰‹ãå‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

