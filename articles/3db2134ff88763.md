---
title: "RustをNimから呼び出す"
emoji: "👑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [
  "nim", "rust"
]
published: false
---

## モチベーション
NimはPythonのような簡単な文法で、C言語にトランスパイルしバイナリにコンパイルすることで、学習コストの低さ、開発の生産性の高さ、実行速度の速さを兼ね揃えたプログラミング言語です。
所有権・借用に基づくスコープベースでの安全なメモリ管理をコンパイラが自動で行い、Go言語のように参照やポインタについて考える必要もないため、特にアプリケーション開発において「コーディングのためのコーディング」を減らせてその記述をビジネスロジックだけに集中させることができます。
しかしまだ普及しているとは言い難く、使わない人の意見を聞くと「ライブラリが少ない」という理由を多く聞きます。
Nimはコンパイル時に一旦C言語に変換するために、既にC言語で存在している資産を簡単に取り込むことができ、動的リンク・静的アーカイブ両方と非常にシームレスに連携することができます。

一方でRustは低レイヤーにおけるメモリ安全を徹底したプログラミング言語で、セグフォやメモリリークを防ぎ非常に高速に動作します。
しかし変数の所有権や借用を開発時に考慮する必要があり、とても学習コストが高いです。少なくとも文系出身2年目PHPerが簡単に扱えるような言語ではありません。

この2つの言語の特徴を考えた時に、数学に基づくアルゴリズムの実装などのライブラリはRustで、アプリケーションはNimで作ると両者のいいとこ取りができるのではないでしょうか。

Nim、Rust両方共にC言語を介したFFIの機構が備わっているため、今回はそれを使ってRustで作ったライブラリをNimのアプリケーションから呼ぶ実験をします。

## 環境構築
NimとRust両方の環境が入ったDockerコンテナを作ります。

```dockerfile
FROM ubuntu:22.04

# prevent timezone dialogue
ENV DEBIAN_FRONTEND=noninteractive

RUN apt update --fix-missing && \
    apt upgrade -y
RUN apt install -y --fix-missing \
        gcc \
        xz-utils \
        ca-certificates \
        curl \
        pkg-config

WORKDIR /root
# ==================== Nim ====================
RUN curl https://nim-lang.org/choosenim/init.sh -sSf | sh -s -- -y
ENV PATH $PATH:/root/.nimble/bin

# ==================== Rust ====================
RUN curl https://sh.rustup.rs -sSf | sh -s -- -y

WORKDIR /application
```

## プロジェクト作成
`/application`配下に`src`ディレクトリを作りそこで作業します。


Nimでプロジェクトを作る
```sh
cd /application/src
nimble init nimapp
```
対話型で聞かれるので、選択肢をTabでサイクルしてEnterで選びます。
`Package type?`では`Binary`を選びます。

```sh
  Info: Package initialisation requires info which could not be inferred.
    ... Default values are shown in square brackets, press
    ... enter to use them.
  Using "nimapp" for new package name
Prompt: Your name? [Anonymous]

Answer:       Using "src" for new package source directory
Prompt: Package type?
    ... Library - provides functionality for other packages.
    ... Binary  - produces an executable for the end-user.
    ... Hybrid  - combination of library and binary
    ... For more information see https://goo.gl/cm2RX5
  Select Cycle with 'Tab', 'Enter' when done
Answer: binary
Prompt: Initial version of package? [0.1.0]

Answer:     Prompt: Package description? [A new awesome nimble package]

Answer:     Prompt: Package License?
    ... This should ideally be a valid SPDX identifier. See https://spdx.org/licenses/.
  Select Cycle with 'Tab', 'Enter' when done
Answer: MIT
Prompt: Lowest supported Nim version? [1.6.10]

Answer:    Success: Package nimapp created successfully
```


Rustでプロジェクトを作る
```sh
cd /application/src
cargo new rustlib --lib
```

こういうディレクトリ構造になります

```
/application
`-- src
    |-- nimapp
    |   |-- nimapp.nimble
    |   |-- src
    |   |   `-- nimapp.nim
    |   `-- tests
    |       |-- config.nims
    |       `-- test1.nim
    `-- rustlib
        |-- Cargo.toml
        `-- src
            `-- lib.rs
```


## 関数を呼ぶ
まずは簡単な、intを足し算するadd関数を作ってみましょう。

### Rust側

```rust:lib.rs
#[no_mangle]
pub extern "C" fn add(a: i64, b: i64) -> i64 {
    return a + b;
}
```

```
#[no_mangle]
```
これを関数に対して付けることで、C/Nimから、Rustで定義した通りの`add`の関数名で呼び出せるようになります。

```rs
pub extern "C"
```
関数に対してこれを付けることで、C/Nimから呼び出せる関数になります。

https://tomoyuki-nakabayashi.github.io/book/interoperability/rust-with-c.html#c-api%E3%81%AE%E4%BD%9C%E6%88%90


ライブラリを出力する時には、`crate-type`を設定します。
動的ライブラリにコンパイルする時には`cdylib`を、静的アーカイブにコンパイルする時には`staticlib`にします。

```toml:Cargo.toml
[package]
name = "rustlib"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
name         = "rustlib"
crate-type   = ["cdylib"]
# crate-type   = ["staticlib"]
```

https://qiita.com/etoilevi/items/4bd4c5b726e41f5a6689


コンパイルします。
```sh
cd /application/src/rustlib
cargo build --release
```
`/application/src/rustlib/target/release/librustlib.so`にShard Objectファイルが出力されました。これをNimから呼び出して使います。

### Nim側
`/application/src/nimapp/src/rustlib.nim`というファイルを作り、Shard Objectにある関数をNimから呼べるようにするためのグルー関数を定義します。

```nim:rustlib.nim
const libpath = "/application/src/rustlib/target/release/librustlib.so"

proc add*(a, b:int64):int64 {.dynlib:libpath, importc: "add".}
```

あとは`nimapp.nim`からこの`add`関数を呼び出せばいいだけです。
```nim:nimapp.nim
import std/unittest
import ./rustlib

suite "test":
  test "add":
    echo add(1, 2)
    check add(1, 2) == 3
```

実行しましょう。
```sh
cd /application/src/nimapp
nim c -r -f --mm:orc src/nimapp
```
```sh:output
[Suite] test
3
  [OK] add
```

呼び出すことができました。

## 動的配列を扱う
RustのVectorをNimで扱うにはどうすればいいでしょうか。
ここではフィボナッチ数列を返す関数を使って説明します。

### Rust側
フィボナッチ数を返す関数、それを内部で呼んでフィボナッチ数列を返す関数を定義します。

```rust:lib.rs
#[no_mangle]
fn fib(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 2) + fib(n - 1),
    }
}

#[no_mangle]
pub extern "C" fn fib_array(n: u64) -> *mut Vec<u64> {
    let mut vector = Vec::with_capacity(n.try_into().unwrap());
    for i in 0..n {
        vector.push(fib(i));
    }
    Box::into_raw(Box::new(vector))
}

#[no_mangle]
pub extern "C" fn get_vector_len(v: &Vec<u64>) -> usize {
    v.len()
}

#[no_mangle]
pub extern "C" fn get_vector_item(v: &Vec<u64>, offset: usize) -> u64 {
    v[offset]
}
```

fib_arrayの返り値の型は`*mut Vec<u64>`にし、関数の最後で`Box::into_raw(Box::new(vector))`を呼んでヒープの生ポインタにして返します。
更にVectorから長さとオフセット位置の値を返す関数も実装します。

### Nim側

```nim:rustlib.nim
type VectorPtr = ptr object

proc fibArrayLib(n:int):VectorPtr {.dynlib:libpath, importc: "fib_array".}
proc len(self:VectorPtr):int {.dynlib:libpath, importc: "get_vector_len".}
proc `[]`(self:VectorPtr, offset:int):int {.dynlib:libpath, importc: "get_vector_item".}
proc fibArray*(n:int):seq[int] =
  let v = fibArrayLib(n)
  defer: v.dealloc()
  var s = newSeq[int](n)
  for i in 0..<v.len:
    s[i] = v[i]
  return s
```

Rustの`get_vector_len`の返り値はヒープの生ポインタなので、それをマッピングするための独自のオブジェクトを`VectorPtr`として定義します。
Nimの関数は全て静的な型チェックとオーバーロードされて動くので、ここで定義した関数は全て`VectorPtr`の型を持つオブジェクトに対してのみ動きます。
`fibArray`関数の中でRust側で定義した関数たちを呼び、生ポインタからVectorの長さとオフセット位置の値を取得し、Nimの動的配列であるSeq(Sequence)に詰め替えて返しています。
Nimでは生ポインタはNimのメモリ管理の管轄外になります。生ポインタのメモリを開放する`dealloc`関数が用意されているので、`defer`を使ってスコープを抜けるとメモリが開放されるようにします。
この`defer`はGo言語と同じです。

では`nimapp`の中で呼び出してみましょう。

```nim:nimapp.nim
import std/unittest
import ./rustlib


suite "test":
  test "add":
    echo add(1, 2)
    check add(1, 2) == 3

  test "fib array":
    let res = fibArray(10)
    echo res
    check res == @[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

```sh
cd /application/src/nimapp
nim c -r -f --mm:orc src/nimapp
```
```sh:output
[Suite] test
3
  [OK] add
@[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
  [OK] fib array
```

呼び出すことができました。


:::message
## 処理をサブモジュールに移動させる
ここまでadd関数とフィボナッチ数列を出力する関数を`lib.rs`に書いてきましたが、サブモジュールに移すこともできます。
その方がコードの見通しがよくなるので、移しましょう。

Rustのディレクトリ構造をこのようにします。

```
.
|-- Cargo.lock
|-- Cargo.toml
`-- src
    |-- lib.rs
    `-- submods
        `-- fib.rs
```

fib.rsに処理を移動させます。
```rust:submods/fib.rs
fn fib(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n - 2) + fib(n - 1),
    }
}

#[no_mangle]
pub extern "C" fn fib_array(n: u64) -> *mut Vec<u64> {
    let mut vector = Vec::with_capacity(n.try_into().unwrap());
    for i in 0..n {
        vector.push(fib(i));
    }
    Box::into_raw(Box::new(vector))
}

#[no_mangle]
pub extern "C" fn get_vector_len(v: &Vec<u64>) -> usize {
    v.len()
}

#[no_mangle]
pub extern "C" fn get_vector_item(v: &Vec<u64>, offset: usize) -> u64 {
    v[offset]
}
```

lib.rsはこのようにします
```rust:lib.rs
mod submods {
    pub mod fib;
}

#[no_mangle]
pub extern "C" fn add(a: i64, b: i64) -> i64 {
    return a + b;
}
```
:::

## カスタム型（独自型、構造体）を扱う
Rustの中で定義した構造体のインスタンスをNimから扱えるようにします。

### Rust側
`submods/person.rs`というファイルを作ります。
数値と文字列のフィールドを持つ`Person`型と、そのコンストラクタ、ゲッターメソッドを定義します。
FFIに出力する関数名はなるべく被らないような命名にした方がいいでしょう。そのためただidを返すメソッド名も`id`ではなく`get_person_id`としています。

```diff rust:lib.rs
  mod submods {
      pub mod fib;
+     pub mod c_ffi;
+     pub mod person;
  }

+ use crate::submods::c_ffi;

  #[no_mangle]
  pub extern "C" fn add(a: i64, b: i64) -> i64 {
      return a + b;
  }
```

```rust:submods/person.rs
use std::ffi::c_char;
use crate::c_ffi;


pub struct Person {
    id: i64,
    name: String,
}

impl Person {
    pub fn new(id: i64, name: String) -> Box<Person> {
        let person = Box::new(Person { id, name });
        person
    }

    pub fn id(&self) -> i64 {
        self.id
    }

    pub fn name(&self) -> String {
        self.name.to_string()
    }
}

// ==================== FFI ====================
#[no_mangle]
pub extern "C" fn new_person(id: i64, _name: *const c_char) -> *mut Person {
    let name = c_ffi::cstirng_to_string(_name);
    let person = Person::new(id, name);
    Box::into_raw(person)
}

#[no_mangle]
pub extern "C" fn get_person_id(person: &Person) -> i64 {
    person.id()
}

#[no_mangle]
pub extern "C" fn get_person_name(person: &Person) -> *mut c_char {
    c_ffi::string_to_cstring(person.name())
}

// ==================== test ====================
#[cfg(test)]
mod person_tests {
    use super::*;

    #[test]
    fn person_test() {
        let person = Person::new(1, "John".to_string());
        assert_eq!(person.id(), 1);
        assert_eq!(person.name(), "John");
    }
}
```

`new_person`関数の引数nameの型は`*const c_char`になっています。これはC言語の文字列をRustで扱うための型です。
反対にRust→C言語へ文字列を返すには`*mut c_char`にします。

`new_person`関数の返り値の型は`*mut Person`です。これは先ほどのフィボナッチ数列と同じく、ヒープの生ポインタになっています。

Nimの文字列もRustの文字列もそれぞれの言語の実行環境の中でみ動作する独自の型です。
そのためC言語を介してNimからRustへ文字列やりとりするためには、相互に変換する必要があります。
ここではまずRust側にC言語の文字列を相互変換する関数を作りました。

```rust:submods/c_ffi.rs
use std::ffi::c_char;
use std::ffi::CStr;
use std::ffi::CString;

pub fn cstirng_to_string(_arg: *const c_char) -> String {
    let arg = unsafe {
        assert!(!_arg.is_null());
        let c_str = CStr::from_ptr(_arg);
        let str_slice = c_str.to_str().unwrap();
        str_slice.to_owned()
    };
    arg
}

pub fn string_to_cstring(_arg: String) -> *mut c_char {
    CString::new(_arg).unwrap().into_raw()
}
```

`person.rs`ではこれを呼び出しています。

### Nim側

```nim:rustlib.nim
type
  PersonObj {.pure, final.} = object
    id:int
    name:cstring

  PersonPtr = ptr PersonObj

  Person* = ref object
    rawPtr: PersonPtr


proc newPerson(id:int, name:cstring):PersonPtr {.dynlib:libpath, importc:"new_person".}
proc new*(_:type Person, id:int, name:string):Person = Person(rawPtr:newPerson(id, name.cstring))

proc getPersonId(self:PersonPtr):int64 {.dynlib:libpath, importc:"get_person_id".}
proc id*(self:Person):int = self.rawPtr.getPersonId().int

proc getPersonName(self:PersonPtr):cstring {.dynlib:libpath, importc:"get_person_name".}
proc name*(self:Person):string = $self.rawPtr.getPersonName()
```

Rustの構造体定義と同じ構造体をNimのobjectで定義します。

実際にRustの関数とやりとりするのはヒープの生ポインタなので、マッピングするためのポインタオブジェクト`PersonPtr`を定義します。
ポインタはNimのメモリ管理の管轄外になりますが、ポインタの型をフィールドに持つ`ref`のオブジェクトは自動でメモリ管理されるので、`Person* = ref object`を定義しNimからはこちらを扱うようにします。これにより`dealloc`使って明示的にメモリ解放をする必要がなくなります。

`newPerson`の引数nameの型は`cstring`です。これがNimの中でのC言語の文字列に相当し、`"文字列".cstring`とすれば型変換することができます。

`name`関数の中では`getPersonName`を呼び出していますが、`getPersonName`の返り値の型は`cstring`なので、`$`を付けて`string`に変換しています。`$`はNimの世界ではあらゆる型を文字列に変換するマジックメソッドです。（実際には全ての型に`$`という同名の関数名で文字列に変換するように実装されている）

```nim
proc new*(_:type Person, id:int, name:string):Person = Person(rawPtr:newPerson(id, name.cstring))
proc id*(self:Person):int = self.rawPtr.getPersonId().int
proc name*(self:Person):string = $self.rawPtr.getPersonName()
```
この3つの関数はNimのアプリケーションから呼び出されRustの関数とマッピングした`newPerson`などの関数を呼び出す処理と型変換を行うグルーコードです。

では呼び出してみましょう。

```nim:nimapp.nim
suite "object":
  test "person":
    let person = Person.new(1, "John")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 1
      person.name() == "John"
```
```sh:output
[Suite] object
Person(rawPtr: PersonPtr(id: 1, name: "John"))
1
John
  [OK] person
```
`PersonPtr`オブジェクトのフィールドへの値のマッピングも、関数呼びだしも上手く行っています。

## セッターを持つ独自型を扱う
これまでインスタンス生成とゲッターメソッドしか扱っていませんが、セッターメソッドでも上手くいくでしょうか
フィールドを更新することができる`UpdatablePerson`型を使って説明します。

### Rust側
```diff rust:lib.rs
  mod submods {
      pub mod fib;
      pub mod c_ffi;
      pub mod person;
+     pub mod updatable_person;
  }

  use crate::submods::c_ffi;

  #[no_mangle]
  pub extern "C" fn add(a: i64, b: i64) -> i64 {
      return a + b;
  }
```

```rust:submods/update_person.rs
use std::ffi::c_char;
use crate::submods::c_ffi;

pub struct UpdatablePerson {
    id: i64,
    name: String,
}

impl UpdatablePerson {
    pub fn new(id: i64, name: String) -> Box<UpdatablePerson> {
        let person = Box::new(UpdatablePerson { id, name });
        person
    }

    pub fn id(&self) -> i64 {
        self.id
    }

    pub fn set_id(&mut self, id: i64) {
        self.id = id
    }

    pub fn name(&self) -> String {
        self.name.to_string()
    }

    pub fn set_name(&mut self, name: String) {
        self.name = name
    }
}


#[no_mangle]
pub extern "C" fn new_updatable_person(id: i64, _name: *const c_char) -> *mut UpdatablePerson {
    let name = c_ffi::cstirng_to_string(_name);
    let person = UpdatablePerson::new(id, name);
    Box::into_raw(person)
}

#[no_mangle]
pub extern "C" fn get_updatable_person_id(person: &UpdatablePerson) -> i64 {
    person.id()
}

#[no_mangle]
pub extern "C" fn set_updatable_person_id(person: &mut UpdatablePerson, id: i64) {
    person.set_id(id)
}

#[no_mangle]
pub extern "C" fn get_updatable_person_name(person: &UpdatablePerson) -> *mut c_char {
    c_ffi::string_to_cstring(person.name())
}

#[no_mangle]
pub extern "C" fn set_updatable_person_name(person: &mut UpdatablePerson, _name: *const c_char) {
    let name = c_ffi::cstirng_to_string(_name);
    person.set_name(name)
}


#[cfg(test)]
mod updatable_person_test {
    use super::*;

    #[test]
    fn test1() {
        let mut person = UpdatablePerson::new(1, "John".to_string());
        assert_eq!(person.id(), 1);
        assert_eq!(person.name(), "John");
        person.set_id(2);
        person.set_name("Paul".to_string());
        assert_eq!(person.id(), 2);
        assert_eq!(person.name(), "Paul");
    }
}
```

### Nim側
```nim:rustlib.nim
type
  UpdatablePersonObj {.pure, final.} = object
    id:int
    name:cstring

  UpdatablePersonPtr = ptr UpdatablePersonObj

  UpdatablePerson* = ref object
    rawPtr: UpdatablePersonPtr


proc newUpdatablePerson(id:int, name:cstring):UpdatablePersonPtr {.dynlib:libpath, importc:"new_updatable_person".}
proc new*(_:type UpdatablePerson, id:int, name:string):UpdatablePerson = UpdatablePerson(rawPtr:newUpdatablePerson(id, name.cstring))

proc getUpdatablePersonId(self:UpdatablePersonPtr):int64 {.dynlib:libpath, importc:"get_updatable_person_id".}
proc id*(self:UpdatablePerson):int = self.rawPtr.getUpdatablePersonId().int

proc setUpdatablePersonId(self:UpdatablePersonPtr, id:int) {.dynlib:libpath, importc:"set_updatable_person_id".}
proc setId*(self:UpdatablePerson, id:int) = self.rawPtr.setUpdatablePersonId(id)

proc getUpdatablePersonName(self:UpdatablePersonPtr):cstring {.dynlib:libpath, importc:"get_updatable_person_name".}
proc name*(self:UpdatablePerson):string = $self.rawPtr.getUpdatablePersonName()

proc setUpdatablePersonName(self:UpdatablePersonPtr, name:cstring) {.dynlib:libpath, importc:"set_updatable_person_name".}
proc setName*(self:UpdatablePerson, name:string) = self.rawPtr.setUpdatablePersonName(name.cstring)
```

呼び出します。

```nim:nimapp.nim
suite "object":
  test "updatable person":
    let person = UpdatablePerson.new(1, "John")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 1
      person.name() == "John"

    person.setId(2)
    person.setName("Paul")
    echo person.repr
    echo person.id()
    echo person.name()
    check:
      person.id() == 2
      person.name() == "Paul"
```
```sh:output
[Suite] object
UpdatablePerson(rawPtr: UpdatablePersonPtr(id: 1, name: "John"))
1
John
UpdatablePerson(rawPtr: UpdatablePersonPtr(id: 2, name: "Paul"))
2
Paul
  [OK] updatable person
```

セッターを使っても上手く呼び出すことができました。

