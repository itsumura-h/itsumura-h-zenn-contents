---
title: "Nimã®ã‚¦ã‚§ãƒ–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰åŒ–ã™ã‚‹ãŸã‚ã®æ–­ç‰‡çš„ãªçŸ¥è­˜"
emoji: "ğŸ‘‘"
type: "idea" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["nim"]
published: true
---

ã»ã‚“ã¨ã†ã¯ã‚¹ã‚¯ãƒ©ãƒƒãƒ—ã«æ›¸ãã‚ˆã†ãªå†…å®¹ã§ã™ãŒã€ã‚¹ã‚¯ãƒ©ãƒƒãƒ—ã¯å‰å¾Œã®ç§»å‹•ãŒã§ããªã„ã®ã§ã“ã¡ã‚‰ã«æ›¸ãã¾ã™ã€‚
éšæ™‚æ›´æ–°ã—ç¶šã‘ã¾ã™ã€‚

---

# èµ·å‹•ã‚³ãƒãƒ³ãƒ‰
```sh
nim c -r --threads:on --mm:orc -d:useMalloc -d:useRealtimeGC main
```

# asynchttpserverã®ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰åŒ–
[asynchttpserver](https://nim-lang.org/docs/asynchttpserver.html)

ã“ã‚Œã‚’
```nim
import
  std/asyncdispatch,
  std/asynchttpserver


proc asyncProc {.async.} =
  var server = newAsyncHttpServer()
  proc cb(req: Request) {.async.} =
    let headers = {"Content-type": "text/plain; charset=utf-8"}
    await req.respond(Http200, "Hello World", headers.newHttpHeaders())

  server.listen(Port(5000))
  while true:
    if server.shouldAcceptRequest():
      await server.acceptRequest(cb)
    else:
      await sleepAsync(500)

waitFor asyncProc()
```

ã“ã†ã˜ã‚ƒ
```nim
import
  std/asyncdispatch,
  std/asynchttpserver,
  std/osproc,  
  std/strformat


proc threadProc() {.thread.} =
  proc asyncProc() {.async.} =
    var server = newAsyncHttpServer(true, true)
    proc cb(req: Request) {.async, gcsafe.} =
      let headers = {"Content-type": "text/plain; charset=utf-8"}
      await req.respond(Http200, "Hello World", headers.newHttpHeaders())

    server.listen(Port(5000))
    while true:
      if server.shouldAcceptRequest():
        await server.acceptRequest(cb)
      else:
        await sleepAsync(500)

  while true:
    try:
      asyncCheck asyncProc()
      runForever()
    except:
      echo repr(getCurrentException())

proc serve() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    echo(&"Starting {countThreads} threads")
    var thr = newSeq[Thread[void]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], threadProc)
    joinThreads(thr)
  else:
    threadProc()

serve()
```

# å®Ÿè¡Œæ™‚ã«ã‚»ãƒƒãƒˆã•ã‚Œã‚‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«å®šç¾©ã—ã¦ã‚ã‚‹ç’°å¢ƒå¤‰æ•°ã‚’ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã‹ã‚‰å‘¼ã¶

```nim:environment.nim
import os

let AppEnv* = getEnv("APP_ENV")
```

```nim:main.nim
import
  os,
  osproc,
  strformat,
  ./environment

proc thread(nThread:int) {.thread.} =
  for i in 1..5:
    echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›®"
    echo AppEnv
    sleep(1000)

proc main() =
  let countThreads = countProcessors()
  var thr = newSeq[Thread[int]](countThreads)
  for i in 1..countThreads:
    createThread(thr[i-1], thread, i)
  joinThreads(thr)

main()
```

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
```sh
APP_ENV="aaa" nim c -r --threads:on --mm:orc -d:useMalloc -d:useRealtimeGC main

> main.nim(6, 6) Error: 'thread' is not GC-safe as it accesses 'AppEnv' which is a global using GC'ed memory
```

---

ç’°å¢ƒå¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã‚‹ã¨ã“ã‚ã‚’ `{.gcsafe.}` ã®ãƒ—ãƒ©ã‚°ãƒã‚’ä»˜ã‘ã¦ã‚ã’ã‚‹

```diff nim:main.nim
import
  os,
  osproc,
  strformat,
  ./environment

proc thread(nThread:int) {.thread.} =
  for i in 1..3:
    echo &"ã‚¹ãƒ¬ãƒƒãƒ‰â€¦{nThread} {i}å›ç›®"
+   {.gcsafe.}:
+     echo AppEnv
    sleep(1000)

proc main() =
  let countThreads = countProcessors()
  var thr = newSeq[Thread[int]](countThreads)
  for i in 1..countThreads:
    createThread(thr[i-1], thread, i)
  joinThreads(thr)

main()
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦2 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦4 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦1 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦3 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦2 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦3 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦1 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦4 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦2 3å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦3 3å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦1 3å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦4 3å›ç›®
aaa
```

# ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã‹ã‚‰RDBã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹
ã‚¯ã‚¨ãƒªãƒ“ãƒ«ãƒ€ã«ã¯ç§ãŒä½œã£ãŸ[alllographer](https://github.com/itsumura-h/nim-allographer)ã‚’ä½¿ã„ã¾ã™

```nim: environment.nim
import
  std/asyncdispatch,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

let rdb* = dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

randomize()

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
rdb.create(
  table("hello", [
    Column.integer("id"),
    Column.integer("randomnumber")
  ])
)

# ã‚·ãƒ¼ãƒ€ãƒ¼
seeder rdb, "hello":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("hello").insert(data).waitFor
```

```nim: main.nim
import
  std/asyncdispatch,
  std/json,
  std/osproc,
  allographer/query_builder,
  ./environment

proc thread(nThread:int) {.thread.} =
  (proc() {.async.} =
    for i in 1..3:
      let res = rdb.table("hello").find(i).await.get
      echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
```

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
```sh
DB_POSTGRES=true nim c -r --threads:on --mm:orc -d:useMalloc -d:useRealtimeGC main

> main.nim(9, 13) Error: 'thread' is not GC-safe as it performs an indirect call here
```


## `{.gcsafe.}`ãƒ—ãƒ©ã‚°ãƒã‚’ä»˜ã‘ã‚‹

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
  std/locks,
  std/os,
  std/osproc,
  allographer/query_builder,
  ./environment

proc thread(nThread:int:int) {.thread.} =
  (proc() {.async.} =
    for i in 1..3:
+     {.gcsafe.}:
        let res = rdb.table("hello").find(i).await.get
        echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
```

ã‚»ã‚°ãƒ•ã‚©ãŒèµ·ããŸã‚Š
```sh
SIGSEGV: Illegal storage access. (Attempt to read from nil?)
Segmentation fault (core dumped)
```

è¤‡æ•°ã®ã‚¯ã‚¨ãƒªã®å®Ÿè¡ŒãŒæ··ã–ã£ãŸã‚Šã—ã¦ã‚¨ãƒ©ãƒ¼ãŒèµ·ãã‚‹
```sh
ERROR:  syntax error at or near "FROM"
LINE 1: SELECT * FROM "hello" LIMIT 1 FROM "hello" LIMIT 1
```

## Lockã‚’ä½¿ã†
[locks](https://nim-lang.org/docs/locks.html)  
[threadsã«ã‚ˆã‚‹lockã®ã‚µãƒ³ãƒ—ãƒ«](https://nim-lang.org/docs/threads.html)

```nim: lockã®ã‚µãƒ³ãƒ—ãƒ«
import std/locks

var
  thr: array[0..4, Thread[tuple[a,b: int]]]
  L: Lock

proc threadFunc(interval: tuple[a,b: int]) {.thread.} =
  for i in interval.a..interval.b:
    acquire(L) # lock stdout
    echo i
    release(L)

initLock(L)

for i in 0..high(thr):
  createThread(thr[i], threadFunc, (i*10, i*10+5))
joinThreads(thr)

deinitLock(L)
```

ã“ã‚Œã«ã‚ˆã‚Šè¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«DBã¸ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ‰±ã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚

```diff nim:environment.nim
import
  std/asyncdispatch,
+ std/locks,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

+ var L*: Lock
+ initLock(L)
let rdb* = dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

randomize()

rdb.create(
  table("hello", [
    Column.integer("id"),
    Column.integer("randomnumber")
  ])
)

seeder rdb, "hello":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("hello").insert(data).waitFor
```

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
+ std/locks,
  std/options,
  std/osproc,
  std/strformat,
  allographer/query_builder,
  ./environment

proc thread(nThread:int) {.thread.} =
  (proc() {.async.} =
    for i in 1..3:
+     withLock(L):
        {.gcsafe.}:
          let res = rdb.table("hello").find(i).await.get
          echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
+ deinitLock(L)
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰1 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰1 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰1 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰3 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰4 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰4 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰4 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰2 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰2 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰2 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰3 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰3 3å›ç›® {"id":3,"randomnumber":4355}
```

æ­£å¸¸ã«å…¨ã¦ã®ã‚¯ã‚¨ãƒªãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŒã€ã‚¹ãƒ¬ãƒƒãƒ‰ãšã¤é †ç•ªã«å®Ÿè¡Œã™ã‚‹ãŸã‚ã€é€Ÿåº¦ãŒé…ã„ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰åŒ–ã—ã¦ã„ã‚‹æ„å‘³ãŒãªã„

## Lockã¯ä½¿ã‚ãšã€å­ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã§RDBã¸ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œã‚‹
```diff nim:environment.nim
import
  std/asyncdispatch,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

+ proc initDb*():Rdb =
+   return dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

randomize()

+ let rdb = initDb()
rdb.create(
  table("hello", [
      Column.integer("id"),
      Column.integer("randomnumber")
  ])
)

seeder rdb, "hello":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("hello").insert(data).waitFor
```

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
  std/options,
  std/osproc,
  std/strformat,
  allographer/query_builder,
  ./environment

proc thread(nThread:int) {.thread.} =
+ let rdb = initDb()
  (proc() {.async.} =
    for i in 1..3:
      {.gcsafe.}:
        let res = rdb.table("hello").find(i).await.get
        echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰3 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰3 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰2 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰3 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰4 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰1 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰2 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰4 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰1 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰2 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰4 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰1 3å›ç›® {"id":3,"randomnumber":4355}
```
ã‚¹ãƒ¬ãƒƒãƒ‰åŒå£«ãŒç«¶åˆã›ãšã«DBã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸãŒã€ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ãƒ‡ã‚¶ã‚¤ãƒ³ä¸Šã€ã©ã†å­ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¸­ã§ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œã‚Šé–‹ç™ºè€…ãŒè§¦ã‚‹ã¨ã“ã‚ã¸å‡ºã™ã‹ã¯é›£ã—ã„ã€‚


## ã‚¹ãƒ¬ãƒƒãƒ‰æ¯ã«Pluginã¨ã„ã†æ¦‚å¿µã‚’æŒã¡ã€ãã“ã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒãŸã›ã‚‹

```diff nim:environment.nim
import
  std/asyncdispatch,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

proc initDb*():Rdb =
  return dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

+ type Plugin* = ref object
+   rdb*: Rdb

randomize()

var rdb = initDb()
rdb.create(
  table("World", [
    Column.integer("id"),
    Column.integer("randomnumber")
  ])
)

seeder rdb, "World":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("World").insert(data).waitFor
```

```diff nim:controller.nim
import
  std/asyncdispatch,
  std/json,
  std/options,
  std/strformat,
  allographer/query_builder,
  ./environment

+ proc controller*(param: (Plugin, int)):Future[void] {.async, gcsafe.} =
+   let (plugin, nThread) = param
    for i in 1..3:
      let res = plugin.rdb.table("hello").find(i).await.get
      echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
```

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
  std/osproc,
  ./environment,
  ./controller

+ proc thread(param:(Plugin, int)) {.thread.} =
    (proc() {.async.} =
      await controller.controller(param)
    )().waitFor


+ proc main(plugins:seq[Plugin]) =
    when compileOption("threads"):
      let countThreads = countProcessors()
+     var thr = newSeq[Thread[(Plugin, int)]](countThreads)
+     for i in 0..countThreads-1:
+       createThread(thr[i], thread, (plugins[i], i+1))
      joinThreads(thr)
    else:
+     thread((plugins[0], 1))

+ var plugins = newSeq[Plugin](countProcessors())
+ for i in 0..countProcessors()-1:
+   plugins[i] = Plugin(
+     rdb:initDb()
+   ) 
+ main(plugins)
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰2 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰3 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰1 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰4 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰2 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰3 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰1 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰4 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰3 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰1 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰4 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰2 3å›ç›® {"id":3,"randomnumber":4355}
```

ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ•°ã ã‘Pluginã®é…åˆ—ã‚’ä½œã‚Šã€å„ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã¯Pluginã‚’æ¸¡ã™ã€‚
ã“ã†ã™ã‚‹ã“ã¨ã§ã‚¹ãƒ¬ãƒƒãƒ‰åŒå£«ãŒåŒã˜Pluginã‚’è§¦ã‚‹ã®ã‚’é˜²ãã€‚
ãƒ¡ãƒ¢ãƒªç®¡ç†ã¯ã‚¹ãƒ¬ãƒƒãƒ‰å˜ä½ã§è¡Œã‚ã‚Œã‚‹ã€‚
Pluginã‚’é€šã—ã¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ä¸­ã§rdbã¸ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ã†ã€‚
