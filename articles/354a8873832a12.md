---
title: "Nimã®ã‚¦ã‚§ãƒ–ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã®æ–­ç‰‡çš„ãªçŸ¥è­˜"
emoji: "ğŸ‘‘"
type: "idea" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["nim"]
published: true
---

ã»ã‚“ã¨ã†ã¯ã‚¹ã‚¯ãƒ©ãƒƒãƒ—ã«æ›¸ãã‚ˆã†ãªå†…å®¹ã§ã™ãŒã€ã‚¹ã‚¯ãƒ©ãƒƒãƒ—ã¯å‰å¾Œã®ç§»å‹•ãŒã§ããªã„ã®ã§ã“ã¡ã‚‰ã«æ›¸ãã¾ã™ã€‚
éšæ™‚æ›´æ–°ã—ç¶šã‘ã¾ã™ã€‚

---

# èµ·å‹•ã‚³ãƒãƒ³ãƒ‰
```sh
nim c -r --threads:on --mm:orc -d:useMalloc -d:useRealtimeGC main
```

# asynchttpserverã®ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰åŒ–
[asynchttpserver](https://nim-lang.org/docs/asynchttpserver.html)

ã“ã‚Œã‚’
```nim
import
  std/asyncdispatch,
  std/asynchttpserver


proc asyncProc {.async.} =
  var server = newAsyncHttpServer()
  proc cb(req: Request) {.async.} =
    let headers = {"Content-type": "text/plain; charset=utf-8"}
    await req.respond(Http200, "Hello World", headers.newHttpHeaders())

  server.listen(Port(5000))
  while true:
    if server.shouldAcceptRequest():
      await server.acceptRequest(cb)
    else:
      await sleepAsync(500)

waitFor asyncProc()
```

ã“ã†ã˜ã‚ƒ
```nim
import
  std/asyncdispatch,
  std/asynchttpserver,
  std/osproc,  
  std/strformat


proc threadProc() {.thread.} =
  proc asyncProc() {.async.} =
    var server = newAsyncHttpServer(true, true)
    proc cb(req: Request) {.async, gcsafe.} =
      let headers = {"Content-type": "text/plain; charset=utf-8"}
      await req.respond(Http200, "Hello World", headers.newHttpHeaders())

    server.listen(Port(5000))
    while true:
      if server.shouldAcceptRequest():
        await server.acceptRequest(cb)
      else:
        await sleepAsync(500)

  while true:
    try:
      asyncCheck asyncProc()
      runForever()
    except:
      echo repr(getCurrentException())

proc serve() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    echo(&"Starting {countThreads} threads")
    var thr = newSeq[Thread[void]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], threadProc)
    joinThreads(thr)
  else:
    threadProc()

serve()
```

# å®Ÿè¡Œæ™‚ã«ã‚»ãƒƒãƒˆã•ã‚Œã‚‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«å®šç¾©ã—ã¦ã‚ã‚‹ç’°å¢ƒå¤‰æ•°ã‚’ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã‹ã‚‰å‘¼ã¶

```nim:environment.nim
import os

let AppEnv* = getEnv("APP_ENV")
```

```nim:main.nim
import
  os,
  osproc,
  strformat,
  ./environment

proc thread(nThread:int) {.thread.} =
  for i in 1..5:
    echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›®"
    echo AppEnv
    sleep(1000)

proc main() =
  let countThreads = countProcessors()
  var thr = newSeq[Thread[int]](countThreads)
  for i in 1..countThreads:
    createThread(thr[i-1], thread, i)
  joinThreads(thr)

main()
```

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
```sh
APP_ENV="aaa" nim c -r --threads:on --mm:orc -d:useMalloc -d:useRealtimeGC main

> main.nim(6, 6) Error: 'thread' is not GC-safe as it accesses 'AppEnv' which is a global using GC'ed memory
```

---

ç’°å¢ƒå¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã‚‹ã¨ã“ã‚ã‚’ `{.gcsafe.}` ã®ãƒ—ãƒ©ã‚°ãƒã‚’ä»˜ã‘ã¦ã‚ã’ã‚‹

```diff nim:main.nim
import
  os,
  osproc,
  strformat,
  ./environment

proc thread(nThread:int) {.thread.} =
  for i in 1..3:
    echo &"ã‚¹ãƒ¬ãƒƒãƒ‰â€¦{nThread} {i}å›ç›®"
+   {.gcsafe.}:
+     echo AppEnv
    sleep(1000)

proc main() =
  let countThreads = countProcessors()
  var thr = newSeq[Thread[int]](countThreads)
  for i in 1..countThreads:
    createThread(thr[i-1], thread, i)
  joinThreads(thr)

main()
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦2 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦4 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦1 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦3 1å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦2 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦3 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦1 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦4 2å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦2 3å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦3 3å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦1 3å›ç›®
aaa
ã‚¹ãƒ¬ãƒƒãƒ‰â€¦4 3å›ç›®
aaa
```

# ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã‹ã‚‰RDBã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹
ã‚¯ã‚¨ãƒªãƒ“ãƒ«ãƒ€ã«ã¯ç§ãŒä½œã£ãŸ[alllographer](https://github.com/itsumura-h/nim-allographer)ã‚’ä½¿ã„ã¾ã™

```nim: environment.nim
import
  std/asyncdispatch,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

let rdb* = dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

randomize()

# ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
rdb.create(
  table("hello", [
    Column.integer("id"),
    Column.integer("randomnumber")
  ])
)

# ã‚·ãƒ¼ãƒ€ãƒ¼
seeder rdb, "hello":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("hello").insert(data).waitFor
```

```nim: main.nim
import
  std/asyncdispatch,
  std/json,
  std/osproc,
  allographer/query_builder,
  ./environment

proc thread(nThread:int) {.thread.} =
  (proc() {.async.} =
    for i in 1..3:
      let res = rdb.table("hello").find(i).await.get
      echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
```

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
```sh
DB_POSTGRES=true nim c -r --threads:on --mm:orc -d:useMalloc -d:useRealtimeGC main

> main.nim(9, 13) Error: 'thread' is not GC-safe as it performs an indirect call here
```


## `{.gcsafe.}`ãƒ—ãƒ©ã‚°ãƒã‚’ä»˜ã‘ã‚‹

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
  std/locks,
  std/os,
  std/osproc,
  allographer/query_builder,
  ./environment

proc thread(nThread:int:int) {.thread.} =
  (proc() {.async.} =
    for i in 1..3:
+     {.gcsafe.}:
        let res = rdb.table("hello").find(i).await.get
        echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
```

ã‚»ã‚°ãƒ•ã‚©ãŒèµ·ããŸã‚Š
```sh
SIGSEGV: Illegal storage access. (Attempt to read from nil?)
Segmentation fault (core dumped)
```

è¤‡æ•°ã®ã‚¯ã‚¨ãƒªã®å®Ÿè¡ŒãŒæ··ã–ã£ãŸã‚Šã—ã¦ã‚¨ãƒ©ãƒ¼ãŒèµ·ãã‚‹
```sh
ERROR:  syntax error at or near "FROM"
LINE 1: SELECT * FROM "hello" LIMIT 1 FROM "hello" LIMIT 1
```

## Lockã‚’ä½¿ã†
[locks](https://nim-lang.org/docs/locks.html)  
[threadsã«ã‚ˆã‚‹lockã®ã‚µãƒ³ãƒ—ãƒ«](https://nim-lang.org/docs/threads.html)

```nim: lockã®ã‚µãƒ³ãƒ—ãƒ«
import std/locks

var
  thr: array[0..4, Thread[tuple[a,b: int]]]
  L: Lock

proc threadFunc(interval: tuple[a,b: int]) {.thread.} =
  for i in interval.a..interval.b:
    acquire(L) # lock stdout
    echo i
    release(L)

initLock(L)

for i in 0..high(thr):
  createThread(thr[i], threadFunc, (i*10, i*10+5))
joinThreads(thr)

deinitLock(L)
```

ã“ã‚Œã«ã‚ˆã‚Šè¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒåŒæ™‚ã«DBã¸ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ‰±ã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚

```diff nim:environment.nim
import
  std/asyncdispatch,
+ std/locks,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

+ var L*: Lock
+ initLock(L)
let rdb* = dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

randomize()

rdb.create(
  table("hello", [
    Column.integer("id"),
    Column.integer("randomnumber")
  ])
)

seeder rdb, "hello":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("hello").insert(data).waitFor
```

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
+ std/locks,
  std/options,
  std/osproc,
  std/strformat,
  allographer/query_builder,
  ./environment

proc thread(nThread:int) {.thread.} =
  (proc() {.async.} =
    for i in 1..3:
+     withLock(L):
        {.gcsafe.}:
          let res = rdb.table("hello").find(i).await.get
          echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
+ deinitLock(L)
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰1 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰1 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰1 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰3 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰4 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰4 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰4 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰2 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰2 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰2 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰3 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰3 3å›ç›® {"id":3,"randomnumber":4355}
```

æ­£å¸¸ã«å…¨ã¦ã®ã‚¯ã‚¨ãƒªãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŒã€ã‚¹ãƒ¬ãƒƒãƒ‰ãšã¤é †ç•ªã«å®Ÿè¡Œã™ã‚‹ãŸã‚ã€é€Ÿåº¦ãŒé…ã„ã€‚ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰åŒ–ã—ã¦ã„ã‚‹æ„å‘³ãŒãªã„

## Lockã¯ä½¿ã‚ãšã€å­ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã§RDBã¸ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œã‚‹
```diff nim:environment.nim
import
  std/asyncdispatch,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

+ proc initDb*():Rdb =
+   return dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

randomize()

+ let rdb = initDb()
rdb.create(
  table("hello", [
      Column.integer("id"),
      Column.integer("randomnumber")
  ])
)

seeder rdb, "hello":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("hello").insert(data).waitFor
```

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
  std/options,
  std/osproc,
  std/strformat,
  allographer/query_builder,
  ./environment

proc thread(nThread:int) {.thread.} =
+ let rdb = initDb()
  (proc() {.async.} =
    for i in 1..3:
      {.gcsafe.}:
        let res = rdb.table("hello").find(i).await.get
        echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
  )().waitFor


proc main() =
  when compileOption("threads"):
    let countThreads = countProcessors()
    var thr = newSeq[Thread[int]](countThreads)
    for i in 1..countThreads:
      createThread(thr[i-1], thread, i)
    joinThreads(thr)
  else:
    thread(1)

main()
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰3 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰3 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰2 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰3 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰4 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰1 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰2 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰4 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰1 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰2 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰4 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰1 3å›ç›® {"id":3,"randomnumber":4355}
```
ã‚¹ãƒ¬ãƒƒãƒ‰åŒå£«ãŒç«¶åˆã›ãšã«DBã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸãŒã€ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ãƒ‡ã‚¶ã‚¤ãƒ³ä¸Šã€ã©ã†å­ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¸­ã§ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œã‚Šé–‹ç™ºè€…ãŒè§¦ã‚‹ã¨ã“ã‚ã¸å‡ºã™ã‹ã¯é›£ã—ã„ã€‚


## ã‚¹ãƒ¬ãƒƒãƒ‰æ¯ã«Pluginã¨ã„ã†æ¦‚å¿µã‚’æŒã¡ã€ãã“ã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒãŸã›ã‚‹

```diff nim:environment.nim
import
  std/asyncdispatch,
  std/random,
  std/json,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder

proc initDb*():Rdb =
  return dbOpen(PostgreSQL, "db_name", "user", "pass", "db_host", 5432, 20, 30, true, false)

+ type Plugin* = ref object
+   rdb*: Rdb

randomize()

var rdb = initDb()
rdb.create(
  table("World", [
    Column.integer("id"),
    Column.integer("randomnumber")
  ])
)

seeder rdb, "World":
  var data = newSeq[JsonNode]()
  for i in 1..10000:
    let randomNum = rand(10000)
    data.add(%*{"id": i, "randomnumber": randomNum})
  rdb.table("World").insert(data).waitFor
```

```diff nim:controller.nim
import
  std/asyncdispatch,
  std/json,
  std/options,
  std/strformat,
  allographer/query_builder,
  ./environment

+ proc controller*(param: (Plugin, int)):Future[void] {.async, gcsafe.} =
+   let (plugin, nThread) = param
    for i in 1..3:
      let res = plugin.rdb.table("hello").find(i).await.get
      echo &"ã‚¹ãƒ¬ãƒƒãƒ‰{nThread} {i}å›ç›® {res}"
```

```diff nim:main.nim
import
  std/asyncdispatch,
  std/json,
  std/osproc,
  ./environment,
  ./controller

+ proc thread(param:(Plugin, int)) {.thread.} =
    (proc() {.async.} =
      await controller.controller(param)
    )().waitFor


+ proc main(plugins:seq[Plugin]) =
    when compileOption("threads"):
      let countThreads = countProcessors()
+     var thr = newSeq[Thread[(Plugin, int)]](countThreads)
+     for i in 0..countThreads-1:
+       createThread(thr[i], thread, (plugins[i], i+1))
      joinThreads(thr)
    else:
+     thread((plugins[0], 1))

+ var plugins = newSeq[Plugin](countProcessors())
+ for i in 0..countProcessors()-1:
+   plugins[i] = Plugin(
+     rdb:initDb()
+   ) 
+ main(plugins)
```

```sh: å‡ºåŠ›
ã‚¹ãƒ¬ãƒƒãƒ‰2 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰3 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰1 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰4 1å›ç›® {"id":1,"randomnumber":2}
ã‚¹ãƒ¬ãƒƒãƒ‰2 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰3 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰1 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰4 2å›ç›® {"id":2,"randomnumber":36}
ã‚¹ãƒ¬ãƒƒãƒ‰3 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰1 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰4 3å›ç›® {"id":3,"randomnumber":4355}
ã‚¹ãƒ¬ãƒƒãƒ‰2 3å›ç›® {"id":3,"randomnumber":4355}
```

ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ•°ã ã‘Pluginã®é…åˆ—ã‚’ä½œã‚Šã€å„ã‚¹ãƒ¬ãƒƒãƒ‰ã«ã¯Pluginã‚’æ¸¡ã™ã€‚
ã“ã†ã™ã‚‹ã“ã¨ã§ã‚¹ãƒ¬ãƒƒãƒ‰åŒå£«ãŒåŒã˜Pluginã‚’è§¦ã‚‹ã®ã‚’é˜²ãã€‚
ãƒ¡ãƒ¢ãƒªç®¡ç†ã¯ã‚¹ãƒ¬ãƒƒãƒ‰å˜ä½ã§è¡Œã‚ã‚Œã‚‹ã€‚
Pluginã‚’é€šã—ã¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ä¸­ã§rdbã¸ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½¿ã†ã€‚

# ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’é€šã—ã¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã«Pluginã‚’æ¸¡ã™
ä¸Šã®ã‚µãƒ³ãƒ—ãƒ«ã§ã¯`main.nim`ãŒ`Plugin`ã®å®šç¾©ã‚’çŸ¥ã£ã¦ã„ã‚‹ã€‚

```sh: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ
.
â”œâ”€â”€ controller.nim
â”œâ”€â”€ fw
â”‚Â Â  â””â”€â”€ lib.nim
â”œâ”€â”€ main
â”œâ”€â”€ main.nim
â””â”€â”€ setting.nim
```

ã“ã®æ™‚ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¾å­˜é–¢ä¿‚ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹
```sh
main â”€â”€> controller â”€â”€> fw/lib
ã€€ã€€ã€€ã€€ã€€ã€€setting
```

PluginãŒã©ã‚“ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ã‹ã¯é–‹ç™ºè€…å´ã®settingãªã©ã§å®šç¾©ã—ãŸã„ã€‚ã—ã‹ã—fw/libã¯Pluginã®å®šç¾©ã«ã¤ã„ã¦ã¯çŸ¥ã‚Šãˆãªã„ã€‚
ã‚‚ã—Pluginã®å®šç¾©ã‚’ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ä¸­ã§ã™ã‚‹ã¨ã€é–‹ç™ºè€…ãŒä»»æ„ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãã“ã«ä¹—ã›ã‚‹ã“ã¨ã¯ã§ããªã„ã“ã¨ã«ãªã‚‹ã€‚

## templateã‚’ä½¿ã†
templateã‚’ä½¿ãˆã°ã€Pluginã‚’å‘¼ã³å‡ºã—ã¦ã„ã‚‹asynchttpserverã®å‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ã‚’é–‹ç™ºè€…å´ã®mainã«æŒã£ã¦ãã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚

```nim: setting.nim
import
  std/asyncdispatch,
  allographer/connection,
  allographer/query_builder


proc initDb*():Rdb =
  return dbOpen(PostgreSQL, "database", "user", "pass", "db", 5432, 20, 30, true, false)

# ============================================================
type Plugin* = ref object
  rdb*:Rdb

proc new*(_:type Plugin):Plugin =
  return Plugin(
    rdb: initDb()
  )

# ============================================================
type Controller* = ref object
  action*: proc(plugin:Plugin):Future[string] {.async, gcsafe.}

proc new*(_:type Controller, action: proc(plugin:Plugin):Future[string] {.async, gcsafe.}):Controller =
  return Controller(action:action)
```
Pluginã®å®šç¾©ã€ãã—ã¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒã©ã‚“ãªå¼•æ•°ã‚’å—ã‘å–ã‚‹ã‹ã‚’é–‹ç™ºè€…å´ã§å®šç¾©ã™ã‚‹ã€‚

```nim: fw/lib.nim
import
  std/httpcore


type Route* = ref object
  path*:string
  httpMethod*:HttpMethod

template serveWithPlugin*(routes, createPlugin:untyped):untyped =
  proc threadProc(params:(seq[(Route, Controller)], Plugin)) {.thread.} =
    proc asyncProc(params:(seq[(Route, Controller)], Plugin)) {.async.} =
      var server = newAsyncHttpServer(true, true)
      proc cb(req: Request) {.async, gcsafe.} =
        let headers = {"Content-type": "text/plain; charset=utf-8"}
        let (routes, plugin) = params
        for route in routes:
          if req.url.path == route[0].path and req.reqMethod == route[0].httpMethod:
            let resp = route[1].action(plugin).await
            await req.respond(Http200, resp, headers.newHttpHeaders())
            break
        await req.respond(Http404, "", headers.newHttpHeaders())

      server.listen(Port(5000))
      while true:
        if server.shouldAcceptRequest():
          await server.acceptRequest(cb)
        else:
          await sleepAsync(500)

    while true:
      try:
        asyncCheck asyncProc(params)
        runForever()
      except:
        echo repr(getCurrentException())

  proc serve(routes:seq[(Route, Controller)], `createPlugin`:proc():Plugin) =
    let countThreads = countProcessors()
    var params:seq[(seq[(Route, Controller)], Plugin)]
    for i in 1..countThreads:
      params.add((routes, `createPlugin`()))
    when compileOption("threads"):
      echo("Starting ", countThreads, " threads")
      var thr = newSeq[Thread[(seq[(Route, Controller)], Plugin)]](countThreads)
      for i in 0..countThreads-1:
        createThread(thr[i], threadProc, params[i])
      joinThreads(thr)
    else:
      threadProc(params[0])

  serve(`routes`, `createPlugin`)
```

```nim: controller.nim
import 
  std/asyncdispatch,
  std/options,
  std/json,
  allographer/query_builder,
  ./setting

proc index*(plugin:Plugin):Future[string] {.async, gcsafe.} =
  for i in 1..10:
    echo plugin.rdb.table("num_table").find(i).await.get()
  return "index"

proc show*(plugin:Plugin):Future[string] {.async, gcsafe.} =
  return "show"
```

```nim: main.nim
import
  std/asyncdispatch,
  std/asynchttpserver,
  std/osproc,
  ./fw/lib,
  ./setting,
  ./controller


let routes = @[
  (Route(path:"/", httpMethod:HttpGet), Controller.new(index)),
  (Route(path:"/show", httpMethod:HttpGet), Controller.new(show))
]

proc createPlugin*():Plugin =
  return Plugin.new()

serveWithPlugin(routes, createPlugin)
```

å‹•ä½œã™ã‚‹
```sh
Starting 4 threads
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["1"]
{"id":1,"randomnumber":7985}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["2"]
{"id":2,"randomnumber":6529}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["3"]
{"id":3,"randomnumber":6613}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["4"]
{"id":4,"randomnumber":1471}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["5"]
{"id":5,"randomnumber":8057}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["6"]
{"id":6,"randomnumber":944}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["7"]
{"id":7,"randomnumber":1194}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["8"]
{"id":8,"randomnumber":5665}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["9"]
{"id":9,"randomnumber":1812}
DEBUG SELECT * FROM num_table WHERE id = ? LIMIT 1 ["10"]
{"id":10,"randomnumber":6917}
```

---

PluginãŒæŒã¤ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®`db_postgres`ã®`DbConn`ã«å·®ã—æ›¿ãˆã¦ã¿ã‚‹

```diff nim:setting.nim
import
  std/asyncdispatch,
+ std/db_postgres


+proc initDb*():DbConn =
+  open("db", "user", "pass", "database")


# ============================================================
type Plugin* = ref object
+ rdb*:DbConn

proc new*(_:type Plugin):Plugin =
  return Plugin(
    rdb: initDb()
  )

# ============================================================
type Controller* = ref object
  action*: proc(plugin:Plugin):Future[string] {.async, gcsafe.}

proc new*(_:type Controller, action: proc(plugin:Plugin):Future[string] {.async, gcsafe.}):Controller =
  return Controller(action:action)
```

```diff nim:controller.nim
import 
  std/asyncdispatch,
  std/db_postgres,
  std/options,
  std/json,
  allographer/query_builder,
  ./setting

proc index*(plugin:Plugin):Future[string] {.async, gcsafe.} =
  for i in 1..10:
+   echo plugin.rdb.getRow(sql"SELECT * FROM num_table WHERE id = ?", i)
  return "index"

proc show*(plugin:Plugin):Future[string] {.async, gcsafe.} =
  return "show"
```

å‹•ä½œã™ã‚‹
```sh
Starting 4 threads
@["1", "7985"]
@["2", "6529"]
@["3", "6613"]
@["4", "1471"]
@["5", "8057"]
@["6", "944"]
@["7", "1194"]
@["8", "5665"]
@["9", "1812"]
@["10", "6917"]
```

## ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯æ¸¬å®š
```nim: controller.nim
import 
  std/asyncdispatch,
  std/options,
  std/json,
  std/strutils,
  std/sequtils,
  allographer/query_builder,
  ./setting


proc index*(plugin:Plugin):Future[string] {.async, gcsafe.} =
  let nThreads = 500
  var futures = newSeq[Future[Option[JsonNode]]](nThreads)
  for i in 1..nThreads:
    futures[i-1] = plugin.rdb.table("num_table").find(i)
  let res = all(futures).await
  let response = res.map(
    proc(x:Option[JsonNode]):JsonNode =
      x.get()
  )
  return $(%response)

proc show*(plugin:Plugin):Future[string] {.async, gcsafe.} =
  return "show"
```

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
```sh
DB_POSTGRES=true nim c -r --threads:{on|off} --mm:{refc|arc|orc} -d:useMalloc -d:useRealtimeGC -d:release main
```

æ¸¬å®š
```sh
wrk -c4 -t4 -d10s http://localhost:5000 # DB access
wrk -c4 -t4 -d10s http://localhost:5000/show # return string
```
|Memory monagement|Threads|DB access|return string|
|---|---|---|---|
|refc|on|33|233624|
|refc|off|151|234453|
|arc|on|88|219813|
|arc|off|166|228683|
|orc|on|81|clash|
|orc|off|137|182754|

ãªãœã‹ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰ã®æ–¹ãŒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒè‰¯ã„(Â´ãƒ»Ï‰ãƒ»ï½€)


# Nimã®éåŒæœŸã¨ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã«é–¢ã™ã‚‹è­°è«–
ã©ã†ã‚„ã‚‰IOãƒã‚¦ãƒ³ãƒ‰ãªå‡¦ç†ã¯ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã§å‹•ã‹ã™ã‚ˆã‚Šã‚‚ã€ã‚·ãƒ³ã‚°ãƒ«ã‚¹ãƒ¬ãƒƒãƒ‰ã§éåŒæœŸã‚’ä½¿ã£ãŸã»ã†ãŒã„ã„ã‚ˆã†ã§ã™ã€‚

[--gc:orc ; Multi-threaded async slower than single-threaded](https://github.com/nim-lang/Nim/issues/15661)
[Criticism of Parallel Nim](https://forum.nim-lang.org/t/7621)
[Channel / Actors based parallelism? Are there such Web Servers?](https://forum.nim-lang.org/t/7583)
[Threading in Nim](https://forum.nim-lang.org/t/7968)

# ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ« VS ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ
[Nimè£½ã‚¯ã‚¨ãƒªãƒ“ãƒ«ãƒ€ã®allographer](https://github.com/itsumura-h/nim-allographer)ã¯ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«ã®ä»•çµ„ã¿ã‚’æŒã£ã¦ã„ã‚‹ã€‚çŸ­æ™‚é–“ã«å¤§é‡ã®DBã‚¢ã‚¯ã‚»ã‚¹ã‚’ã™ã‚‹æ™‚ã«ã€ã‚ã‚‹ã‚¯ã‚¨ãƒªãŒaã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ã£ã¦ã„ã‚‹ã¨ã€ä»–ã®ã‚¯ã‚¨ãƒªã§ã¯bã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ã£ã¦DBã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã€‚aã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã®ä½¿ç”¨ä¸­ã®çŠ¶æ…‹ãŒè§£é™¤ã•ã‚ŒãŸã‚‰åˆ¥ã®ã‚¯ã‚¨ãƒªãŒã¾ãŸaã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ã†ã€‚PostgreSQLã§ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§100ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’å¼µã‚‹ã“ã¨ãŒã§ãã‚‹ã®ã§ã€95ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãã‚‰ã„ãªã‚‰åŒæ™‚ã«ä½¿ã£ã¦å¤§é‡ã®DBã‚¢ã‚¯ã‚»ã‚¹ã‚’æŒãã“ã¨ãŒã§ãã‚‹ã€‚
ä¸€æ–¹ã§ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«ã‚’ä½¿ã£ãŸã‚¯ã‚¨ãƒªå®Ÿè¡Œã¯ã€æ¯å›ã‚¯ã‚¨ãƒªã‚’ãƒ‘ãƒ¼ã‚¹ã—æ§‹æ–‡ã‚’è§£é‡ˆã—å€¤ã‚’ãƒã‚¤ãƒ³ãƒ‰ã—ã¦ã„ã‚‹ã€‚ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ãˆã°ã‚¯ã‚¨ãƒªã®ãƒ‘ãƒ¼ã‚¹ã¯1å›ã§æ¸ˆã¿ã€å€¤ã®ãƒã‚¤ãƒ³ãƒ‰ã ã‘ã‚’è¡Œãˆã°ã„ã„ã®ã§ã€åŒã˜æ§‹æ–‡ã®ã‚¯ã‚¨ãƒªã‚’ä½•å›ã‚‚å®Ÿè¡Œã™ã‚‹å ´åˆã¯ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã®æ–¹ãŒé€Ÿã„ã‚‰ã—ã„ã€‚ã—ã‹ã—ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã¯ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³å˜ä½ã§ä½œã‚‰ã‚Œã‚‹ãŸã‚ã€1ã¤ã®ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ã¯1ã¤ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ã„å›ã•ãªã‘ã‚Œã°ã„ã‘ãªã„ã€‚
ä»Šå›ã¯æ¯å›ã‚¯ã‚¨ãƒªã®ãƒ‘ãƒ¼ã‚¹ã‚’ã—ã¦ã‚‚è¤‡æ•°ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ã£ãŸã»ã†ãŒé€Ÿã„ã®ã‹ã€ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ã£ãŸã»ã†ãŒé€Ÿã„ã®ã‹å®Ÿé¨“ã—ã¦ã¿ã‚‹ã€‚

```sh
DB_POSTGRES=true nim c -r --threads:off --mm:arc -d:useMalloc -d:useRealtimeGC -d:release main
```

```nim:main.nim
import 
  std/asyncdispatch,
  std/json,
  std/options,
  std/random,
  std/times,
  allographer/connection,
  allographer/schema_builder,
  allographer/query_builder,
  allographer/async/async_db

randomize()

let rdb = dbOpen(PostgreSQL, "database", "user", "pass", "db", 5432, 96, 30, false, false)

proc init() =
  rdb.create(
    table("num_threads", [
        Column.integer("id"),
        Column.integer("randomnumber")
    ])
  )

  seeder rdb, "num_threads":
    var data = newSeq[JsonNode]()
    for i in 1..10000:
      let randomNum = rand(10000)
      data.add(%*{"id": i, "randomnumber": randomNum})
    rdb.table("num_threads").insert(data).waitFor


proc main(){.async.} =
  init()
  let n = 500
  # ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ
  block:
    let start = cpuTime()
    var resp = newJArray()
    let conn = rdb.conn
    let prepare = conn.prepare(PostgreSQL, "select * from num_table where id = $1 LIMIT 1", "12345").await
    var futures = newSeq[Future[(seq[Row], DbRows)]](n)
    for i in 1..n:
      futures[i-1] = prepare.query(PostgreSQL, @[$i])
    
    let resArr = all(futures).await
    for res in resArr:
      let rows = res[0]
      for row in rows:
        let dbInfo = res[1]
        resp.add(%*{dbInfo[0][0].name: row[0], dbInfo[0][1].name: row[1]})
    # echo resp
    echo cpuTime() - start

  # ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«
  block:
    let start = cpuTime()
    var resp = newJArray()
    var futures = newSeq[Future[Option[JsonNode]]](n)
    for i in 1..n:
      futures[i-1] = rdb.table("num_table").find(i)
    let resArr = all(futures).await
    for rowOpt in resArr:
      resp.add(rowOpt.get)
    # echo resp
    echo cpuTime() - start


main().waitFor
```

çµæœ
|ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ|ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«|
|---|---|
|0.5787295100000001|0.05459516299999989|

ãªã‚“ã¨10å€ä»¥ä¸Šã®å·®ã ã£ãŸã€‚ãƒ—ãƒªãƒšã‚¢ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚ˆã‚Šã‚‚ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒ«ã‚’ä½¿ã£ãŸæ–¹ãŒåœ§å€’çš„ã«é€Ÿã‹ã£ãŸã€‚


<!-- # ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã™ã‚‹ -->
<!-- RDBã¯ã‚¹ãƒ¬ãƒƒãƒ‰æ¯ã«ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œã‚Šã€ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹æ™‚ã«ã¯ã‚¹ãƒ¬ãƒƒãƒ‰å˜ä½ã®ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ãŸã‚ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã«ãªã‚‹ã€‚ -->
<!-- ã—ã‹ã—ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰1ãƒ¶æ‰€ã®Redisã«æ¥ç¶šã™ã‚‹ãŸã‚ã«ã€Lockãªã©ã‚’ä½¿ã†å¿…è¦ãŒã‚ã‚‹ã€‚ -->
